# ES入门

[toc]

---

## 1 基本概念

### 1.1 基本介绍

ElasticSearch（简称es）是一个分布式的高可用准实时搜索引擎。其本质是一个基于Lucene搜索库实现的分布式文件系统，内部采用es组织数据索引结构，对外提供一系列搜索功能解决方案的api。 



### 1.2 集群（Cluster）

一个es集群由一组es**节点**组成，一个**节点**代表一个es所在jvm进程，通常情况我们会在一台物理机上部署1~n个es进程，每个进程叫做一个节点或实例。不过单个机器所能承载的节点数通常是有限的。

<img src="./1-ES入门.assets/截屏2023-08-30 16.54.09.png" alt="截屏2023-08-30 16.54.09" style="zoom:50%;" />



### 1.3 节点（Node）

集群中介绍了节点的概念，即一个es进程表示一个节点，而节点通常分为以下几种类型：

1. master: *node.master:true* 的节点，表示 **有资格参与master竞选** 的节点，主节点通常用来管理集群状态，节点发现，元数据信息管理等作用。 **特别注意**: 真正的主节点只有一个，其他的master node仅仅是具有选举权但并不起到主节点的作用；
2. data: *node.data:true* 的节点，表示存储数据节点。数据节点用来存储索引的数据到磁盘，并不参与主节点选取，集群状态维护等工作，通常数据节点会选择性能比较好的机器（ssd，大内存等）部署；
3. tribe: 该角色在6.x以及更高的版本被移除了，在5.x版本中该角色用来执行跨集群搜索/写入等路由功能；
4. ingest: *node.ingest:true* 的节点，用来对请求进行过滤转换操作，支持Pipline配置，通常用在ETL的环节中；
5. coordinate: 这个角色比较特殊，也十分重要，我们可以称之为 **协调节点** 因为每个节点都是潜在的协调节点，当一个节点不属于以上四种之一时，它也是一个协调节点，可以把它当成NGINX一样作为请求路由的功能；

<img src="./1-ES入门.assets/截屏2023-08-30 16.54.44.png" alt="截屏2023-08-30 16.54.44" style="zoom:50%;" />



### 1.4 索引（Index）

es的索引是一个集合的概念，我们都知道es是基于Lucene实现的分布式搜索引擎，因此es的索引可以理解为每个Lucene索引组成的集合，**一==组==Lucene索引构成了一个完整的es索引**。

<img src="./1-ES入门.assets/截屏2023-08-30 16.55.13.png" alt="截屏2023-08-30 16.55.13" style="zoom:50%;" />



### 1.5 分片（Shard）

分片是索引之下的概念，**==每个分片其实本质上就是一个Lucene索引，多个Lucene索引构成了一个完整的es索引==**。

分片又可以分为**主分片**和**副本**，主分片是一个完整索引的一部分数据，而副本是一个主分片的镜像。

**<u>注意同一个编号主分片和副本不可以出现在同一个机器上</u>**，这样不能满足容灾和副本负载的功能，没有意义。

可以这么说：主分片的作用是能够起到数据跨机器存储，降低单机存储的压力，而副本的作用是起到数据容灾和负载均衡的功能。其实这本质上和传统的分布式系统的分片概念是一样的，所以说es是一个带有特殊结构的分布式文件系统不为过。

<img src="./1-ES入门.assets/截屏2023-08-30 16.56.03.png" alt="截屏2023-08-30 16.56.03" style="zoom:50%;" />



### 1.6 段（Segment）

一个段是一个Lucene索引内部的分片，实际上段不是es原生的概念，而是Lucene的特性，每当Lucene写入一次数据并落盘时都会产生一个分段，分段是不可变的，只能读取和删除。

<img src="./1-ES入门.assets/截屏2023-08-30 16.56.32.png" alt="截屏2023-08-30 16.56.32" style="zoom:50%;" />

### 1.7 索引缓冲区（IndexBuffer）

当我们写入一条数据时，数据并不会直接写入底层文件中，而是会先放入某一个实例下的index buffer内，当index buffer触发策略同步索引时才会真正发起一次写入操作，底层Lucene则是会发起一次 segment commit, 产生一个新的段，此时数据可以被检索到。这个过程我们可以称之为 **refresh**

Index Buffer同步策略有2个：

1. 当达到 *index.refresh_interval*的时长，执行一次refresh
2. 当IndexBuffer写满时，触发一次 refresh。

策略1默认时间为1秒，策略2 IndexBuffer默认大小为当前es进程内存的10%。因此我们说es是**准实时**的搜索引擎，数据写入到能被查询到至少有1秒的延迟。

由此我们还可以得出结论：需要实时准确查询得到结果的业务（例如对账）不可以依赖es。



### 1.8 事务日志（TransLog）

用过Mysql、Redis和Hbase等分布式系统的同学对事务日志一定不陌生，这类日志通常也被称作：**WAL**（Write Ahead Log）,即每次写入数据同时都会将写数据行为记录到一个日志中，这个日志包括了数据本身和操作（插入更新删除），作用是用来在节点发生宕机时对数据进行修复。es的事务日志叫做translog，每当一次写请求到来时es将记录这一次操作，当节点宕机后，es会根据commit point对数据进行恢复。

同时translog也是有大小限制的，每当translog达到一定大小或一定时间时会执行一次**flush**操作，强制将文件系统缓存中的数据同步到磁盘中（即产生一次磁盘IO），并清空日志。



### 1.9 健康状态（Health）

集群有三种健康状态分别由三种颜色表示，green，yellow，red。看上去很简单但是总是有同学不能准确理解这三种状态的含义，所以这里我来挨个解释下

1. green: 这个很简单，就是集群健康运转时候的状态；
2. yellow: 当有**副本**丢失的时候处于该状态；
3. red: 当有**主分片**丢失的时候处于该状态；



## 2 搜索过程

1. 首先client的请求经过es的 协调节点（coordinate node），协调节点会解析请求中的ppreference参数决定是走默认的路由策略还是定制的策略；

2. 假设是默认的路由策略，协调节点将会从本地路由表中找到目标索引有哪些主分片或副本以及分别在哪些节点上。随机选择主或副将请求发往每个shard上，例如你有0，1，2三个主分片一个副本，会发往这三个分片号所在的主分片或副本的节点；
3. 每个到达分片对应机器的请求，执行查询语法解析分词等一系列操作后，执行查询操作，默认取回10条数据（请求可以设置）的docId作为结果，这一步叫做 `query`
4. 每个shard执行完均返回10条数据到发起请求的协调节点，协调节点聚合这N个节点返回的结果到一条优先队列，取top 10(或搜索时指定条数)个docId，再根据这些docId所在shard，去指定的机器获取其他属性值并返回，这一步叫做`fetch`。
5. 协调节点将数据返回client。



### 2.1 query阶段

<img src="./1-ES入门.assets/截屏2023-08-30 17.30.41.png" alt="截屏2023-08-30 17.30.41" style="zoom:50%;" />

### 2.2 fetch阶段

<img src="./1-ES入门.assets/截屏2023-08-30 17.31.35.png" alt="截屏2023-08-30 17.31.35" style="zoom:50%;" />

==**remind**几个细节：==

1. 搜索要去整个分片查，不然可能会漏数据；
2. 副本也能用来检索；



## 3 写入过程

1. 请client求还是来到协调节点，协调节点首先根据文档的id计算一个hash值，并通过hash值定位到应该去哪个主分片；如果用户没有设置id，则会使用 TimeBasedUUID算法并做base64最终生成一个20位长度的字母大小写和数字混合的字符串，保证唯一性，并根据这个id计算hash找到应该去哪个主分片；
2. 请求路由到对应的主分片，立马写入IndexBuffer，并同时记录下当前操作到Translog，当IndexBufferda触发条件时，refresh数据到文件系统缓存中，此时Lucene产生一个可被检索的segment。当然写入时还会经历数据分词，包括类型判断，解析，归一化等等，数字还会有压缩算法等等这里不做详细说明；
3. 当Translog达到触发条件（文件超过大小或一定时间）则会触发一次操作系统的缓存刷写（fsync），产生一次磁盘io，并清空日志，此时数据被真正落地到磁盘。当然操作系统缓存也有自己的同步策略，当脏页达到一定大小会被同步到磁盘中并清空；
4. 在步骤2执行完后，当前节点会将这个请求同步到其他副本分片上，副本还会重复3这个步骤。根据集群的数据一致性配置，写入请求会决定是立即告诉协调节点写入完成，还是等待半数副本同步完成，还是全部副本同步完成时再告诉协调节点写入完成；
5. 协调节点接收到写入完成的响应，并响应client写入完成；

### 流程图

<img src="./1-ES入门.assets/截屏2023-08-30 17.38.13.png" alt="截屏2023-08-30 17.38.13" style="zoom:50%;" />

**remind**几个细节：

1. 写数据永远先写主分片；
2. 这里注意，副本同步不像MySQL使用binlog的形式，而是在写入过程中直接散发请求。至于为啥官方不使用Translog进行数据同步，我猜测可能主要和Translog的机制有关，毕竟它达到一定大小或一定时间就会主动刷盘然后干掉了；