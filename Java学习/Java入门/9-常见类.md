# 九、常见类



## 9.1 字符串相关类



### 9.1.1 String的使用

***String 的特征：***

- `String` 类：代表字符串。Java 程序中的所有字符串字面值（如`"abc"`）都作为此类的实例实现。
- `String` 是一个`final` 类，代表***不可变的字符序列***。
- 字符串是常量，用双引号引起来表示。他们的值在创建之后不可更改。
- `String` 对象的字符内容是储存在一个字符数组`value[]` 中的。



### 9.1.2 String的不可变性

1. `String` 声明为`final` 的，***不可被继承***；
2. `String` 实现了`Serializable` 接口：表示字符串是支持序列化的；实现了`Comparable` 接口：表示`String` 可以比较大小；
3. `String` 内部定义了`final char[] value` 用于存储字符串数据；
4. `String`: 代表不可变的字符序列。简称：不可变性；
   体现：
   -  当对字符串重新赋值时，需要***<u>重写指定内存区域赋值</u>***，不能使用原有的`value` 进行赋值；
   - 当对现有的字符串进行连接操作时，也需要***<u>重新指定内存区域赋值</u>***，不能使用原有的`value` 进行赋值；
   - 当调用`String` 的`replace()` 方法***修改指定字符或字符串***时，***<u>也需要重新指定内存区域赋值</u>***，不能使用原有的`value`进行赋值；
5. 通过***<u>字面量的方式</u>***（区别于`new`）给一个字符串赋值，此时的字符串值***声明在字符串常量池中***；
6. ***字符串常量池中是<u>不会</u>存储相同内容的字符串的***；

```java
import org.testng.annotations.Test;

public class StringTest {
    @Test
    public void Test1() {
        String s1 = "abc"; // 字面量的定义方式
        String s2 = "abc";
        s1 = "hello";
        System.out.println(s1 == s2); // 比较s1 和s2 的地址值
        System.out.println(s1); // hello
        System.out.println(s2); // abc
        System.out.println("*********************");
        String s3 = "abc";
        s3 += "def";
        System.out.println(s3); // abcdef
        System.out.println("**********************");
        String s4 = "abc";
        String s5 = s4.replace('a', 'm');
        System.out.println(s4); // abc
        System.out.println(s5); // mbc
    }
}
```

![字符串内存](image\字符串内存.png)



### 9.1.3 String不同实例化方式的对比

```java
String str = "hello";

// 本质上this.value = new char[0];
String s1 = new String();

//this.value = original.value;
String s2 = new String(String original);

//this.value = Arrays.copyOf(value, value.length);
String s3 = new String(char[] a);

String s4 = new String(char[] a,int startIndex,int count);
```

***String 的实例化方式：***

- 方式一：通过字面量定义的方式
- 方式二：通过new + 构造器的方式

面试题：`String s = new String("abc")；`方式创建对象，在内存中创建了几个对象？
***<u>两个</u>***：一个是堆空间中**<u>new 结构</u>**，另一个是char[] 对应的**<u>常量池中的数据</u>**：`"abc"`；



```java
import org.testng.annotations.Test;

public class StringTest {
    @Test
    public void test2() {
        // 通过字面量定义的方式：此时的s1 和s2 的数据javaEE 声明在方法区中的字符串常量池中。
        String s1 = "javaEE";
        String s2 = "javaEE";
        // 通过new + 构造器的方式：此时的s3 和s4 保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。
        String s3 = new String("javaEE");
        String s4 = new String("javaEE");
        System.out.println(s1 == s2); // true
        System.out.println(s1 == s3); // false
        System.out.println(s1 == s4); // false
        System.out.println(s3 == s4); // false
        System.out.println("***********************");
        Person p1 = new Person("Tom", 12);
        Person p2 = new Person("Tom", 12);
        System.out.println(p1.name.equals(p2.name)); // true
        System.out.println(p1.name == p2.name); // true
        System.out.println("***********************");
        Person p3 = new Person("Tom");
        Person p4 = new Person("Tom");
        System.out.println(p3.name == p4.name); // false
    }
}

class Person {
    public String name;
    int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Person(String name) {
        this.name = new String(name);
    }

    public Person() {
    }
}
```

![字符串内存2](image\字符串内存2.png)



### 9.1.4 String不同拼接对比

1. ***<u>常量与常量</u>的拼接结果在常量池***。且***常量池中不会存在相同内容的常量***；
2. 只要***其中有<u>一个是变量</u>***，结果就**在堆中**；
3. 如果拼接的结果调用`intern()` 方法，返回值就在常量池中；

```java
import org.testng.annotations.Test;

public class StringTest {
    @Test
    public void test3() {
        String s1 = "javaEE";
        String s2 = "hadoop";
        String s3 = "javaEEhadoop";
        String s4 = "javaEE" + "hadoop";
        String s5 = s1 + "hadoop";
        String s6 = "javaEE" + s2;
        String s7 = s1 + s2;
        System.out.println(s3 == s4); // true
        System.out.println(s3 == s5); // false
        System.out.println(s3 == s6); // false
        System.out.println(s5 == s6); // false
        System.out.println(s3 == s7); // false
        System.out.println(s5 == s6); // false
        System.out.println(s5 == s7); // false
        System.out.println(s6 == s7); // false
        String s8 = s5.intern(); // 返回值得到的s8 使用的常量值中已经存在的“javaEEhadoop”
        System.out.println(s3 == s8); // true
    }
    
    @Test
    public void test4() {
        String s1 = "javaEEhadoop";
        String s2 = "javaEE";
        String s3 = s2 + "hadoop";
        System.out.println(s1 == s3); // false
        final String s4 = "javaEE"; // s4:常量
        String s5 = s4 + "hadoop";
        System.out.println(s1 == s5); // true
    }
}
```



***String 使用陷阱：***

1. `String s1 = “a”`;
   说明：在字符串常量池中创建了一个字面量为"a" 的字符串。
2. `s1 = s1 + “b”`;
   说明：实际上原来的`“a”`字符串对象已经丢弃了，现在在堆空间中产生了一个字符串`s1+“b”`（也就是"ab")。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。
3. `String s2 = “ab”`;
   说明：直接在字符串常量池中创建一个字面量为"ab" 的字符串。
4. `String s3 = “a” + “b”`;
   说明：s3 指向字符串常量池中已经创建的"ab" 的字符串。
5. `String s4 = s1.intern()`;
   说明：堆空间的`s1` 对象在调用`intern()` 之后，会将常量池中已经存在的`"ab"` 字符串赋值给`s4`。



### 9.1.5 String的一道面试题

```java
public class StringTest {

    String str = new String("good");
    char[] ch = {'t', 'e', 's', 't'};

    public void change(String str, char[] ch) {
        str = "test ok";
        ch[0] = 'b';
    }

    public static void main(String[] args) {
        StringTest ex = new StringTest();
        ex.change(ex.str, ex.ch);
        System.out.println(ex.str); // good
        System.out.println(ex.ch); // best
    }
}
```



### 9.1.6 JVM中涉及字符串内存结构

<img src="image\JVM内存结构.png" alt="JVM内存结构" style="zoom:50%;" />



<img src="image\JVM分类.png" alt="JVM分类" style="zoom:50%;" />



***Heap 堆：***
一个`JVM` 实例只存在一 个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后: 需要把类方法常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存分为三部分:

- `Young Generation Space 新生区` *Young*
- `Tenure Generation Space 养老区` *Old*
- `Permanent Space 永久存储区` *Perm*  ----->  `方法区`

实际而言，***方法区(Method Area) 和堆一样，是<u>各个线程共享的内存区域</u>***，它用于存储虚拟机加载的：类信息+ 普通常量+ 静态变量+ 编译器编译后的代码等等，虽然`JVM` 规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap( 非堆)， 目的就是要和堆分开。

对于`HotSpot` 虚拟机， 很多开发者习惯将方法区称之为*" 永久代(Permanent Gen)"*，但严格本质上说两者不同，或者说使用永久代来实现方法区而已，永久代是方法区的一个实现，`jdk1.7` 的版本中，已经将原本放在永久代的字符串常量池移走。

常量池(Constant Pool) 是方法区的一部分， Class 文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，这部分内容将在类加载后进入方法区的运行时常量池中存放。

![堆与方法区](image\堆与方法区.png)



***新生区：***
新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用, 最后被垃圾回收器收集, 结束生命。新生区又分为两部分：`伊甸区(Eden space)`和`幸存者区(Survivor space)`， 所有的***类都是在伊甸区被new 出来***的。幸存区有两个: `0 区( Survivor 0 space ) 和1 区( Suvivor 1 space )`。***当伊甸园的空间用完时***, 程序又需要创建对象，`JVM` 的垃圾回收器将对伊甸园区进行垃圾回收`(Minor GC)`，将伊甸园区中的不再被其他对象所引用的对象进行销毁。然后将伊甸园中的剩余对象移动到幸存0 区。若幸存0 区也满了，再对该区进行垃圾回收，然后移动到1 区。那如果1 区也满了呢？再移动到养老区。若养老区也满了, 那么这个时候将产生`Major GC (FullGC)`，进行养老区的内存清理。若养老区执行了`Full GC` 之后发现依然无法进行对象的保存，就会产生`OOM` 异常`OutOfMemoryError`。

如果出现`java.lang.OutOfMemoryError: Java heap space` 异常，说明Java虚拟机的堆内存不够。原因有二：

- Java 虚拟机的堆内存设置不够，可以通过参数`-Xms、-Xmx`来调整；
- 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集( 存在被引用）--->***内存溢出; 内存泄漏***；



***永久区：***

永久存储区是一个***常驻内存区域***，用于存放`JDK` 自身所携带的`Class,Interface` 的元数据，也就是说它存储的是运行环境必须的类信息，***被装载进此区域的数据是不会被垃圾回收器回收掉的***，关闭`JVM` 才会释放此区域所占用的内存。

如果出现`java.lang.OutOfMemoryError: PermGen space`，说明是Java 虚拟机对`永久代Perm`内存设置不够。一般出现这种情况，都是程序启动需要加载大量的第三方jar 包。例如：在一个Tomcat下部署了太多的应用。或者大量动态反射生成的类不断被加载，最终导致Perm 区被占满。

- `Jdk1.6` 及之前：常量池分配在永久代，1.6 在方法区；
- `Jdk1.7` : 有，但已经逐步“去永久代”，1.7 在堆；
- `Jdk1.8` 及之后：无，1.8 在元空间；



### 9.1.7 String的常用方法1

- `int length()`：返回字符串的长度：`return value.length`；
- `char charAt(intindex)`：返回某索引处的字符`return value[index]`； 
- `boolean isEmpty()`：判断是否是空字符串：`returnvalue.length==0`；
- `String toLowerCase()`：使用默认语言环境，将`String` 中的所有字符转换为小写；
- `String toUpperCase()`：使用默认语言环境，将`String` 中的所有字符转换为大写；
- `String trim()`：返回字符串的副本，***忽略前导空白和尾部空白***；
- `boolean equals(Object obj)`：比较字符串的内容是否相同；
- `boolean equals IgnoreCase(String anotherString)`：与`equals` 方法类似，***<u>忽略大小写</u>***；
- `String concat(Stringstr)`：将指定字符串连接到此字符串的结尾。等价于用`“+”`；
- `int compareTo(String anotherString)`：比较两个字符串的大小；
- `String substring(int beginIndex)`：返回一个新的字符串，它是此字符串的从`beginIndex` 开始截取到最后的一个子字符串；
- `String substring(int beginIndex,intendIndex)`：返回一个新字符串，它是此字符串从`beginIndex` 开始截取到`endIndex`***( 不包含）*** 的一个子字符串；

```java
import org.testng.annotations.Test;

public class StringMethodTest {
    @Test
    public void Test1() {
        String s1 = "helloworld";
        System.out.println(s1.length());
        System.out.println(s1.length());
        System.out.println(s1.charAt(0));
        System.out.println(s1.charAt(9));
        // System.out.println(s1.charAt(10));
        // s1 = "";
        System.out.println(s1.isEmpty());
        String s2 = s1.toLowerCase();
        System.out.println(s1);// s1 不可变的，仍然为原来的字符串
        System.out.println(s2);// 改成小写以后的字符串
        String s3 = " he llo world ";
        String s4 = s3.trim();
        System.out.println("-----" + s3 + "-----");
        System.out.println("-----" + s4 + "-----");
    }
    
    @Test
    public void test2() {
        String s1 = "HelloWorld";
        String s2 = "helloworld";
        System.out.println(s1.equals(s2)); // false
        System.out.println(s1.equalsIgnoreCase(s2));// true
        String s3 = "abc";
        String s4 = s3.concat("def");
        System.out.println(s4);// abcdef
        String s5 = "abc";
        String s6 = new String("abe");
        System.out.println(s5.compareTo(s6)); // -2
        // 涉及到字符串的排序
        String s7 = "周围好吵啊";
        String s8 = s7.substring(2);
        System.out.println(s7);
        System.out.println(s8);
        String s9 = s7.substring(0, 2);
        System.out.println(s9);
    }
}
```



### 9.1.8 String 的常用方法2

- `boolean endsWith(String suffix)`：测试此字符串是否以指定的后缀结束。

- `boolean startsWith(String prefix)`：测试此字符串是否以指定的前缀开始。

- `boolean startsWith(String prefix, int toffset)`：测试此字符串从指定索引开始的子字符串是否以指定前缀开始。

- `boolean contains(CharSequence s)`：当且仅当此字符串包含指定的char值序列时，返回 true

- `int indexOf(String str)`：返回指定子字符串在此字符串中第一次出现处的索引。

- `int indexOf(String str, int fromIndex)`：返回指定子字符串在此字符串中第一次出现处的索引，***从指定的索引开始***。

- `int lastIndexOf(String str)`：返回指定子字符串在此字符串中最右边出现处的索引。

- `int lastIndexOf(String str, int fromIndex)`：返回指定子字符串在此字符串中最后一次出现处的索引，***从指定的索引开始<u>反向搜索</u>***。

  **注：`indexOf` 和`lastIndexOf` 方法如果未找到都是返回`-1`。**

```java
import org.testng.annotations.Test;

public class StringMethodTest {
    @Test
    public void test3() {
        String str1 = "helloworld";
        boolean b1 = str1.endsWith("rld");
        System.out.println(b1);
        boolean b2 = str1.startsWith("He");
        System.out.println(b2);
        boolean b3 = str1.startsWith("ll", 2);
        System.out.println(b3);
        String str2 = "wor";
        System.out.println(str1.contains(str2));
        System.out.println(str1.indexOf("lo"));
        System.out.println(str1.indexOf("lo", 5));
        String str3 = "hellorworld";
        System.out.println(str3.lastIndexOf("or"));
        System.out.println(str3.lastIndexOf("or", 6));
        // 什么情况下，indexOf(str) 和lastIndexOf(str) 返回值相同？
        // 情况一：存在唯一的一个str。情况二：不存在str
    }
}
```



### 9.1.9 String的常用方法3

***替换：***

- `String replace(char oldChar, char newChar)`：返回一个新的字符串，它是通过用 `newChar` ***替换此字符串中出现的<u>所有</u>*** `oldChar` 得到的。
- `String replace(CharSequence target, CharSequence replacement)`：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。
- `String replaceAll(String regex, String replacement)`：使用给定的 `replacement`替换此字符串***<u>所有</u>***匹配给定的***正则表达式的子字符串***。
- `String replaceFirst(String regex, String replacement)`：使用给定replacement 替换此字符串匹配给定的正则表达式的***<u>第一个</u>***子字符串。

***匹配：***

- `boolean matches(String regex)`：告知此字符串是否匹配给定的正则表达式。

***切片：***

- `String[] split(String regex)`：根据给定正则表达式的匹配拆分此字符串。
- `String[] split(String regex, int limit)`：根据匹配给定的正则表达式来拆分此字符串，最多***不超过***`limit`个，如果超过了，剩下的全部都放到最后一个元素中。

```java
public class StringMethodTest {
     @Test
    public void test4() {
        String str1 = " 西藏布达拉宫欢迎您";
        String str2 = str1.replace('西', '东');
        System.out.println(str1);
        System.out.println(str2);
        String str3 = str1.replace("西藏", "南京");
        System.out.println(str3);
        System.out.println("*************************");
        String str = "12hello34world5java7891mysql456";
        // 把字符串中的数字替换成','，如果结果中开头和结尾有，的话去掉
        String string = str.replaceAll("\\d+", ",").replaceAll("^,|,$", "");
        System.out.println(string);
        System.out.println("*************************");
        str = "12345";
        // 判断str 字符串中是否全部有数字组成，即有1-n 个数字组成
        boolean matches = str.matches("\\d+");
        System.out.println(matches);
        String tel = "0571-4534289";
        // 判断这是否是一个杭州的固定电话
        boolean result = tel.matches("0571-\\d{7,8}");
        System.out.println(result);
        System.out.println("*************************");
        str = "hello|world|java";
        String[] strs = str.split("\\|");
        for (int i = 0; i < strs.length; i++) {
            System.out.println(strs[i]);
        }
        System.out.println();
        str2 = "hello.world.java";
        String[] strs2 = str2.split("\\.");
        for (int i = 0; i < strs2.length; i++) {
            System.out.println(strs2[i]);
        }
    }
}
```



### 9.1.10 String 与基本数据类型包装的转换

- `String` --> 基本数据类型、包装类：调用包装类的静态方法：`parseXxx(str)`；
- 基本数据类型、包装类 --> `String`: 调用`String` 重载的`valueOf(xxx)`；

```java
import org.testng.annotations.Test;

public class StringTest1 {
    @Test
    public void test1() {
        String str1 = "123";
        // int num = (int)str1; // 错误的
        int num = Integer.parseInt(str1);
        String str2 = String.valueOf(num); // "123
        String str3 = num + "";
        System.out.println(str1 == str3); // false
    }
}
```



### 9.1.11 String 与 char[] 之间的转换

- `String` --> char[]: 调用`String` 的`toCharArray()`；
- `char[]` --> `String`: 调用`String` 的构造器；



```java
import org.testng.annotations.Test;

public class StringTest1 {
    @Test
    public void test2() {
        String str1 = "abc123"; // 题目：a21cb3
        char[] charArray = str1.toCharArray();
        for (int i = 0; i < charArray.length; i++) {
            System.out.println(charArray[i]);
        }
        char[] arr = new char[]{'h', 'e', 'l', 'l', 'o'};
        String str2 = new String(arr);
        System.out.println(str2);
    }
}
```



### 9.1.12 String 与 byte[] 之间的转换



- 编码：`String` --> `byte[]`: 调用`String` 的`getBytes()`

- 解码：`byte[]` --> `String`: 调用`String` 的构造器

- 编码：字符串 --> 字节 ( 看得懂 ---> 看不懂的二进制数据)

- 解码：编码的逆过程，字节 --> 字符串 （看不懂的二进制数据 ---> 看得懂）

  说明：***解码时，要求解码使用的字符集必须与编码时使用的<u>字符集一致</u>，否则会出现乱码。***

```java
import org.testng.annotations.Test;
import java.io.UnsupportedEncodingException;
import java.util.Arrays;

public class StringTest1 {
    @Test
    public void test3() throws UnsupportedEncodingException {
        String str1 = "abc123 重工";
        byte[] bytes = str1.getBytes();
        // 使用默认的字符编码集, 进行转换
        System.out.println(Arrays.toString(bytes));
        byte[] gbks = str1.getBytes("gbk");
        // 使用gbk 字符集进行编码。
        System.out.println(Arrays.toString(gbks));
        System.out.println("*****************************");
        String str2 = new String(bytes);
        // 使用默认的字符集，进行解码。
        System.out.println(str2);
        String str3 = new String(gbks);
        System.out.println(str3);
        // 出现乱码。原因：编码集和解码集不一致！
        String str4 = new String(gbks, "gbk");
        System.out.println(str4);
        // 没有出现乱码。原因：编码集和解码集一致！
    }
}
```



### 9.1.13 面试例题

***获取两个字符串中最大相同字串：***

```java
import org.testng.annotations.Test;

import java.util.Arrays;

public class StringDemo {

    // 前提：两个字符串中只有一个最大相同子串
    public String getMaxSameString(String str1, String str2) {
        if (str1 != null && str2 != null) {
            String maxStr = (str1.length() >= str2.length()) ? str1 :
                    str2;
            String minStr = (str1.length() < str2.length()) ? str1 :
                    str2;
            int length = minStr.length();
            for (int i = 0; i < length; i++) {
                for (int x = 0, y = length - i; y <= length; x++,
                        y++) {
                    String subStr = minStr.substring(x, y);
                    if (maxStr.contains(subStr)) {
                        return subStr;
                    }
                }
            }
        }
        return null;
    }

    // 如果存在多个长度相同的最大相同子串
    // 此时先返回String[]，后面可以用集合中的ArrayList 替换，较方便
    public String[] getMaxSameString1(String str1, String str2) {
        if (str1 != null && str2 != null) {
            StringBuffer sBuffer = new StringBuffer();
            String maxString = (str1.length() > str2.length()) ? str1 : str2;
            String minString = (str1.length() > str2.length()) ? str2 : str1;
            int len = minString.length();
            for (int i = 0; i < len; i++) {
                for (int x = 0, y = len - i; y <= len; x++, y++) {
                    String subString = minString.substring(x, y);
                    if (maxString.contains(subString)) {
                        sBuffer.append(subString + ",");
                    }
                }
                //System.out.println(sBuffer);
                if (sBuffer.length() != 0) {
                    break;
                }
            }
            String[] split = sBuffer.toString().replaceAll(",$", "").
                    split("\\,");
            return split;
        }
        return null;
    }

    @Test
    public void testGetMaxSameString() {
        String str1 = "abcwerthello1yuiodefabcdef";
        String str2 = "cvhello1bnmabcdef";
        String[] maxSameStrings = getMaxSameString1(str1, str2);
        System.out.println(Arrays.toString(maxSameStrings));
    }
}
```



### 9.1.14 StringBuffer 和 StringBuilder 的介绍

- `String`：***不可变***的字符序列；底层使用`char[]` 存储；
- `StringBuffer`：可变的字符序列；***线程安全的，<u>效率低</u>***；底层使用`char[]`存储；
- `StringBuilder`：可变的字符序列；`jdk5.0` 新增的，***<u>线程不安全</u>的，效率高***；底层使用`char[]` 存储；



默认情况下，扩容为原来容量的2 倍 + 2，同时将原有数组中的元素复制到新的数组中；

***意义***：开发中建议大家使用：`StringBuffer(int capacity)` 或`StringBuilder(int capacity)`；



### 9.1.15 StringBuffer中的常用方法

- `StringBuffer append(xxx)`：提供了很多的`append()` 方法，用于进行字符串拼接；
- `StringBuffer delete(int start,int end)`：删除指定位置的内容；
- `StringBuffer replace(int start,int end,String str)`：把[start,end)位置替换为str；
- `StringBuffer insert(int offset, xxx)`：在指定位置插入xxx；
- `StringBuffer reverse()` ：把当前字符序列逆转；
- `public int indexOf(String str)`；
- `public String substring(int start,int end)`: 返回一个从`start` 开始到`end` 索引结束的左闭右开区间的子字符串；
- `public int length()`；
- `public char charAt(int n )`；
- `public void setCharAt(int n ,char ch)`；

***总结：***

- 增：`append(xxx)`
- 删：`delete(int start,int end)`
- 改：`setCharAt(int n ,char ch) / replace(int start, int end, String str)`
- 查：`charAt(int n )`
- 插：`insert(int offset, xxx)`
- 长度：`length()`
- 遍历：`for() + charAt() / toString()`



### 9.1.16 String、StringBuffer、StringBuilder 效率低比

- 从高到低排列：`StringBuilder` > `StringBuffer` > `String`

```java
import org.testng.annotations.Test;

public class StringBufferBuilderTest {
    @Test
    public void test1() {
        StringBuffer sb1 = new StringBuffer("abc");
        sb1.setCharAt(0, 'm');
        System.out.println(sb1);
        StringBuffer sb2 = new StringBuffer();
        System.out.println(sb2.length()); // 0
    }

    @Test
    public void test2() {
        StringBuffer s1 = new StringBuffer("abc");
        s1.append(1);
        s1.append('1');
        System.out.println(s1);
        // s1.delete(2,4);
        // s1.replace(2,4,"hello");
        // s1.insert(2,false);
        // s1.reverse();
        String s2 = s1.substring(1, 3);
        System.out.println(s1);
        System.out.println(s1.length());
        System.out.println(s2);
    }

    @Test
    public void test3() {
        // 初始设置
        long startTime = 0L;
        long endTime = 0L;
        String text = "";
        StringBuffer buffer = new StringBuffer("");
        StringBuilder builder = new StringBuilder("");
        // 开始对比
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 20000; i++) {
            buffer.append(String.valueOf(i));
        }
        endTime = System.currentTimeMillis();
        System.out.println("StringBuffer 的执行时间：" + (endTime - startTime));
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 20000; i++) {
            builder.append(String.valueOf(i));
        }
        endTime = System.currentTimeMillis();
        System.out.println("StringBuilder 的执行时间：" + (endTime - startTime));
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 20000; i++) {
            text = text + i;
        }
        endTime = System.currentTimeMillis();
        System.out.println("String 的执行时间：" + (endTime - startTime));
    }

}
```



## 9.2 时间获取



### 9.2.1 System 类中获取时间戳的方法

`System` 类提供的`public static long currentTimeMillis()`用来返回当前时间与`1970 年1 月1 日0 时0 分0 秒`之间以毫秒为单位的时间差。

***此方法适于计算时间差***。



***计算世界时间的主要标准有：***

- `UTC(Coordinated Universal Time)`
- `GMT(Greenwich Mean Time)`
- `CST(Central Standard Time)`



### 9.2.2 两个 Data 类的使用

`java.util.Date` 类 ---> 表示特定的瞬间，精确到毫秒 。

​		|---`java.sql.Date` 类



1. 两个构造器的使用
> 构造器一：Date()：创建一个对应当前时间的Date 对象；
> 构造器二：创建指定毫秒数的Date 对象 。
2. 两个方法的使用
> `toString()`: 显示当前的年、月、日、时、分、秒 ；
> `getTime()`: 获取当前Date 对象对应的毫秒数。**（时间戳）**。
3. `java.sql.Date` 对应着数据库中的日期类型的变量
> 如何实例化 ；
> 如何将`java.util.Date` 对象转换为`java.sql.Date` 对象。

```java
import org.testng.annotations.Test;
import java.util.Date;

public class DataTimeTest {

    // System 类中的currentTimeMillis()
    @Test
    public void test1() {
        long time = System.currentTimeMillis();
        // 返回当前时间与1970 年1 月1 日0 时0 分0 秒之间以毫秒为单位的时间差。
        // 称为时间戳
        System.out.println(time);
    }

    @Test
    public void test2() {
        // 构造器一：Date()：创建一个对应当前时间的Date 对象
        Date date1 = new Date();
        System.out.println(date1.toString());
        // Sat May 09 20:09:11 CST 2020
        System.out.println(date1.getTime()); // 1589026216998
        // 构造器二：创建指定毫秒数的Date 对象
        Date date2 = new Date(1589026216998L);
        System.out.println(date2.toString());
        // 创建java.sql.Date 对象
        java.sql.Date date3 = new java.sql.Date(35235325345L);
        System.out.println(date3); // 1971-02-13
        // 如何将java.util.Date 对象转换为java.sql.Date 对象
        // 情况一：
        // Date date4 = new java.sql.Date(2343243242323L);
        // java.sql.Date date5 = ( java.sql.Date) date4;
        // 情况二：
        Date date6 = new Date();
        java.sql.Date date7 = new java.sql.Date(date6.getTime());
    }
}

```



## 9.3 JDK 8 之前的日期时间API



### 9.3.1 SimpleDataFormat 的使用

`Date` 类的API 不易于国际化，大部分被废弃了，`java.text.SimpleDateFormat`类是一个不与语言环境有关的方式来格式化和解析日期的具体类。

- 格式化：日期 —> 文本
- 解析：文本 —> 日期
- `SimpleDataFormat`的实例化



### 9.3.2 Calendar 日历类的使用

`Calendar` 是一个抽象基类，主用用于完成日期字段之间相互操作的功能。

***获取`Calendar` 实例的方法：***

- 使用`Calendar.getInstance()` 方法；
- 调用它的子类`GregorianCalendar` 的构造器。

一个Calendar 的实例是***系统时间的抽象表示***，通过`get(int field)` 方法来取得想要的时间信息。比如`YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_、DAY 、MINUTE、SECOND`

- `public void set(int field,int value)`；
- `public void add(int field,int amount)`；
- `public final Date getTime()`；
- `public final void setTime(Date date)`。

***注意：***

- 获取月份时：一月是0，二月是1，以此类推，12 月是11；
- 获取星期时：周日是1，周二是2，。。。。周六是7；



### 9.3.3 练习

```java
import org.testng.annotations.Test;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class DateTime {

    @Test
    public void testSimpleDateFormat() throws ParseException {
        // 实例化SimpleDateFormat
        SimpleDateFormat sdf = new SimpleDateFormat();
        // 格式化：日期---》字符串
        Date date = new Date();
        System.out.println(date); // Sun May 10 16:34:30 CST 2020
        String format = sdf.format(date);
        System.out.println(format); // 20-5-10 下午4:34
        // 解析：格式化的逆过程，字符串---》日期
        String str = "19-12-18 上午11:43";
        Date date1 = sdf.parse(str);
        System.out.println(date1);
        // Wed Dec 18 11:43:00 CST 2019
        // ************* 按照指定的方式格式化和解析：调用带参的构造器*****************
        // SimpleDateFormat sdf1 = new SimpleDateFormat("yyyyy.MMMMM.dd GGG hh:mm aaa");
        SimpleDateFormat sdf1 = new SimpleDateFormat("yyyyy. MMMMM.dd GGG hh:mm aaa");
        // 格式化
        String format1 = sdf1.format(date);
        System.out.println(format1);
        // 02020. 五月.10 公元 04:32 下午
        // 解析: 要求字符串必须是符合SimpleDateFormat 识别的格式(通过构造器参数体现),
        // 否则，抛异常
        Date date2 = sdf1.parse("02020. 五月.10 公元 04:32 下午");
        System.out.println(date2);
        // Sun May 10 16:32:00 CST 2020
    }

    // 练习1：字符串"2020-09-08" 转换为java.sql.Date
    @Test
    public void testExer() throws ParseException {
        String birth = "2020-09-08";
        SimpleDateFormat sdf1 = new SimpleDateFormat("yyyy- MM-dd");
        Date date = sdf1.parse(birth);
        // System.out.println(date);
        java.sql.Date birthDate = new java.sql.Date(date.getTime());
        System.out.println(birthDate);
    }

    //Calendar 日历类的使用
    @Test
    public void testCalendar() {
        // 1. 实例化
        // 方式一：创建其子类（GregorianCalendar）的对象
        // 方式二：调用其静态方法getInstance()
        Calendar calendar = Calendar.getInstance();
        // System.out.println(calendar.getClass());
        //class java.util.GregorianCalendar
        // 2. 常用方法
        // get()
        int days = calendar.get(Calendar.DAY_OF_MONTH);
        System.out.println(days); // 10
        System.out.println(calendar.get(Calendar.DAY_OF_YEAR));
        // 131, 今天是这一年的131 天
        // set()
        // calendar 可变性
        calendar.set(Calendar.DAY_OF_MONTH, 22);
        days = calendar.get(Calendar.DAY_OF_MONTH);
        System.out.println(days); // 22
        // add()
        calendar.add(Calendar.DAY_OF_MONTH, -3);
        days = calendar.get(Calendar.DAY_OF_MONTH);
        System.out.println(days); // 22-3 --》19
        // getTime():日历类---> Date
        Date date = calendar.getTime();
        System.out.println(date); // Tue May 19 17:12:06 CST 2020
        // setTime():Date ---> 日历类
        Date date1 = new Date();
        calendar.setTime(date1);
        days = calendar.get(Calendar.DAY_OF_MONTH);
        System.out.println(days); // 10
    }
}
```



## 9.4 JDK 8 中的日期时间API

如果我们可以跟别人说：“我们在 1502643933071 见面，别晚了！” 那么就再简单不过了。但是我们希望时间与昼夜和四季有关，于是事情就变复杂了。JDK 1.0 中包含了一个 java.util.Date 类，但是它的大多数方法已经在 JDK 1.1 引入 Calendar 类之后被弃用了。而 Calendar 并不比 Date 好多少。它们面临的问题是：

- 可变性：像日期和时间这样的类应该是不可变的。
- 偏移性：Date 中的年份是从 1900 开始的，而月份都从 0 开始。
- 格式化：格式化只对 Date 有用，Calendar 则不行。
- 此外，它们也不是线程安全的；不能处理闰秒等。  

```java
import org.testng.annotations.Test;
import java.util.Date;

public class JDK8DateTimeTest {
        @Test
        public void testDate() {
            // 偏移量
            Date date1 = new Date(2020, 9, 8);
            System.out.println(date1); // Fri Oct 08 00:00:00 CST 3920
            Date date2 = new Date(2020 - 1900, 9 - 1, 8);
            System.out.println(date2); // Tue Sep 08 00:00:00 CST 2020
        }
}
```



### 9.4.1 LocalDate、LocalTime、LocalDateTime的使用

LocalDate、LocalTime、LocalDateTime 类是其中较重要的几个类，它们的实例是不可变的对象，分别表示使用 ISO-8601 日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。

- LocalDate 代表 IOS 格式（yyyy-MM-dd）的日期 , 可以存储生日、纪念日等日期。

- LocalTime 表示一个时间，而不是日期。

- LocalDateTime 是用来表示日期和时间的，这是一个最常用的类之一。

***注：ISO-8601 日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是公历***  

```java
public class JDK8DateTimeTest {
    
    @Test
    public void test1() {
        // now(): 获取当前的日期、时间、日期 + 时间
        LocalDate localDate = LocalDate.now();
        LocalTime localTime = LocalTime.now();
        LocalDateTime localDateTime = LocalDateTime.now();
        System.out.println(localDate);
        System.out.println(localTime);
        System.out.println(localDateTime);
        // of(): 设置指定的年、月、日、时、分、秒。没有偏移量
        LocalDateTime localDateTime1 = LocalDateTime.of(2020, 10, 6, 13, 23, 43);
        System.out.println(localDateTime1);
        // getXxx()：获取相关的属性
        System.out.println(localDateTime.getDayOfMonth());
        System.out.println(localDateTime.getDayOfWeek());
        System.out.println(localDateTime.getMonth());
        System.out.println(localDateTime.getMonthValue());
        System.out.println(localDateTime.getMinute());
        // 体现不可变性
        // withXxx(): 设置相关的属性
        LocalDate localDate1 = localDate.withDayOfMonth(22);
        System.out.println(localDate);
        System.out.println(localDate1);
        LocalDateTime localDateTime2 = localDateTime.withHour(4);
        System.out.println(localDateTime);
        System.out.println(localDateTime2);
        // 不可变性
        LocalDateTime localDateTime3 = localDateTime.plusMonths(3);
        System.out.println(localDateTime);
        System.out.println(localDateTime3);
        LocalDateTime localDateTime4 = localDateTime.minusDays(6);
        System.out.println(localDateTime);
        System.out.println(localDateTime4);
    } 
}
```

<img src="image/时间1.png" alt="时间1" style="zoom:50%;" />



### 9.4.2 Instant类的使用

Instant：时间线上的一个瞬时点。这可能被用来记录应用程序中的事件时间戳。

在处理时间和日期的时候，我们通常会想到年 , 月 , 日 , 时 , 分 , 秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在 UNIX 中，这个数从 1970 年开始，以秒为的单位；同样的，在 Java 中，也是从 1970 年开始，但以毫秒为单位。

java.time 包通过值类型 Instant 提供机器视图，不提供处理人类意义上的时间单位。Instant 表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自 1970 年 1 月 1 日 0 时 0 分 0 秒（UTC）开始的秒数。因为 java.time 包是基于纳秒计算的，所以 Instant 的精度可以达到***<u>纳秒级</u>***  

```java
public class JDK8DateTimeTest {
	@Test
    public void test2() {
        // now(): 获取本初子午线对应的标准时间
        Instant instant = Instant.now();
        System.out.println(instant);
        // 添加时间的偏移量
        OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8));// 东八区
        System.out.println(offsetDateTime);
        // toEpochMilli(): 获取自 1970 年 1 月 1 日 0 时 0 分 0 秒（UTC）开始的毫秒数 --> Date 类的 getTime()
        long milli = instant.toEpochMilli();
        System.out.println(milli); // 1589104867591
        // ofEpochMilli(): 通 过 给 定 的 毫 秒 数， 获 取 Instant 实例-->Date(long millis)
        Instant instant1 = Instant.ofEpochMilli(1550475314878L);
        System.out.println(instant1); // 2019-02-18T07:35:14.878Z
    }
}
```



### 9.4.3 DateTimeFormatter的使用

`java.time.format.DateTimeFormatter` 类：该类提供了三种格式化方法：

- 预定义的标准格式。如：`ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME`;
- 本地化相关的格式。如：`ofLocalizedDateTime(FormatStyle.LONG)`;
- 自定义的格式。如：`ofPattern(“yyyy-MM-dd hh:mm:ss”)`;

```java
public class JDK8DateTimeTest {
	@Test
    public void test3() {
        // 方式一：预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME
        DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
        // 格式化 : 日期 --> 字符串
        LocalDateTime localDateTime = LocalDateTime.now();
        String str1 = formatter.format(localDateTime);
        System.out.println(localDateTime);
        System.out.println(str1);
        // 解析：字符串 --> 日期
        TemporalAccessor parse = formatter.parse("2020-05-10T18:26:40.234");
        System.out.println(parse);
        // 方式二：
        // 本地化相关的格式。如：ofLocalizedDateTime()
        // FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于 LocalDateTime
        DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);
        // 格式化
        String str2 = formatter1.format(localDateTime);
        System.out.println(str2);
        // 本地化相关的格式。如：ofLocalizedDate()
        // FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT: 适用于 LocalDate
        DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM);
        // 格式化
        String str3 = formatter2.format(LocalDate.now());
        System.out.println(str3);
        // 重点：方式三：自定义的格式。如：ofPattern(“yyyy-MMdd hh:mm:ss”)
        DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm:ss");
        // 格式化
        String str4 = formatter3.format(LocalDateTime.now());
        System.out.println(str4);
        // 解析
        TemporalAccessor accessor = formatter3.parse("2020-05-10 06:26:40");
        System.out.println(accessor);
    }
}
```



### 9.4.4 其他日期时间相关API的使用

- `ZoneId`：该类中包含了所有的时区信息，一个时区的 ID，如 `Europe/Paris`。
- `ZonedDateTime`：一个在 ISO-8601 日历系统时区的日期时间，如 `2007-12-03T10:15:30+01:00Europe/Paris`。
- 其中每个时区都对应着 ID，地区 ID 都为“{ 区域 }/{ 城市 }”的格式，例如：`Asia/Shanghai` 等。  

- `Clock`：使用时区提供对当前即时、日期和时间的访问的时钟。
- 持续时间：`Duration`，用于计算两个“时间”间隔。
- 日期间隔：`Period`，用于计算两个“日期”间隔。
- `TemporalAdjuster` : 时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作。
- `TemporalAdjusters` : 该类通过静态方法 (`firstDayOfXxx()/lastDayOfXxx()/nextXxx()`) 提供了大量的常用 `TemporalAdjuster` 的实现。  

<img src="image/时间2.png" alt="时间2" style="zoom:50%;" />

## 9.5 Java比较器



### 9.5.1 概述

Java 中的对象，正常情况下，只能进行比较：`==` 或 `!=` 。不能使用 `>`或 `<` 的，但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。 如何实现？使用两个接口中的任何一个：`Comparable`或 `Comparator`。

Java 实现对象排序的方式有两种：

- 自然排序：`java.lang.Comparable`
- 定制排序：`java.util.Comparator`  



### 9.5.2 Comparable自然排序举例

Comparable 接口的使用举例：自然排序

1. 像 String、包装类等实现了 Comparable 接口，重写了 compareTo(obj) 方法，给出了比较两个对象大小的方式。
2. 像 String、包装类重写 compareTo() 方法以后，进行了从小到大的排列
3. 重写 compareTo(obj) 的规则：
   - 如果当前对象 this 大于形参对象 obj，则返回正整数，
   - 如果当前对象 this 小于形参对象 obj，则返回负整数，
   - 如果当前对象 this 等于形参对象 obj，则返回零。
4. 对于自定义类来说，如果需要排序，我们可以让自定义类实现 Comparable
   接口，重写 compareTo(obj) 方法。在 compareTo(obj) 方法中指明如何排序。  

 ```java
 public class ComparableTest {
     @Test
     public void test1() {
         String[] arr = new String[] { "AA", "CC", "KK", "MM", "GG", "JJ", "DD" };
         Arrays.sort(arr);
         System.out.println(Arrays.toString(arr));
     }
 }
 ```



### 9.5.3 自定义实现Comparable自然排序

```java
public class ComparableTest {

    @Test
    public void test2() {
        Goods[] arr = new Goods[5];
        arr[0] = new Goods("lenovoMouse", 34);
        arr[1] = new Goods("dellMouse", 43);
        arr[2] = new Goods("xiaomiMouse", 12);
        arr[3] = new Goods("huaweiMouse", 65);
        arr[4] = new Goods("microsoftMouse", 43);
        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}

class Goods implements Comparable {
    private String name;
    private double price;

    public Goods() {
    }

    public Goods(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getPrice() {
        return price;
    }
    public void setPrice(double price) {
        this.price = price;
    }

    @Override
    public String toString() {
        return "Goods{" + "name='" + name + '\'' + ", price=" +
                price + '}';
    }

    // 指明商品比较大小的方式 : 按照价格从低到高排序 , 再按照产品名称从高到低排序
    @Override
    public int compareTo(Object o) {
        if (o instanceof Goods) {
            Goods goods = (Goods) o;
            // 方式一：
            if (this.price > goods.price) {
                return 1;
            } else if (this.price < goods.price) {
                return -1;
            } else {
                return -this.name.compareTo(goods.name);
            }
            /*
            //方式2
            if(this.price!=goods.price){
                return Double.compare(this.price,goods.price);
            }else {
                return -this.name.compareTo(goods.name);
            }*/
        }
        throw new RuntimeException("数据类型不一致！");
    }
}
```



### 9.5.4 使用Comparator实现定制排序

Comparable 接口与 Comparator 的使用的对比：

Comparable 接口的方式一旦一定，保证 Comparable 接口实现类的对象在任何位置都可以比较大小。Comparator 接口属于临时性的比较。

Comparator 接口的使用：定制排序

1. 背景：当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了 java.lang.Comparable 接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序
2. 重写 compare(Object o1,Object o2) 方法，比较 o1 和 o2 的大小：如果方法返回正整数，则表示 o1 大于 o2；如果返回 0，表示相等；返回负整数，表示 o1 小于 o2。  

```java
public class ComparableTest {
    @Test
    public void test3() {
        String[] arr = new String[]{"AA", "CC", "KK", "MM", "GG", "JJ", "DD"};
        Arrays.sort(arr, new Comparator() {
            // 按照字符串从大到小的顺序排列
            @Override
            public int compare(Object o1, Object o2) {
                if (o1 instanceof String && o2 instanceof String) {
                    String s1 = (String) o1;
                    String s2 = (String) o2;
                    return -s1.compareTo(s2);
                }
                throw new RuntimeException(" 输入的数据类型不一致 ");
            }
        });
        System.out.println(Arrays.toString(arr));
    }

    @Test
    public void test4() {
        Goods[] arr = new Goods[6];
        arr[0] = new Goods("lenovoMouse", 34);
        arr[1] = new Goods("dellMouse", 43);
        arr[2] = new Goods("xiaomiMouse", 12);
        arr[3] = new Goods("huaweiMouse", 65);
        arr[4] = new Goods("huaweiMouse", 224);
        arr[5] = new Goods("microsoftMouse", 43);
        Arrays.sort(arr, new Comparator() {
            // 指明商品比较大小的方式 : 按照产品名称从低到高排序 ,再按照价格从高到低排序
            @Override
            public int compare(Object o1, Object o2) {
                if (o1 instanceof Goods && o2 instanceof Goods) {
                    Goods g1 = (Goods) o1;
                    Goods g2 = (Goods) o2;
                    if (g1.getName().equals(g2.getName())) {
                        return -Double.compare(g1.getPrice(), g2.getPrice());
                    } else {
                        return g1.getName().compareTo(g2.getName());
                    }
                }
                throw new RuntimeException(" 输入的数据类型不一致 ");
            }
        });
        System.out.println(Arrays.toString(arr));
    }
}
```



## 9.6 System类、Math类、BigInteger与BigDecimal



### 9.6.1 System类

System 类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于 java.lang 包。

由于该类的构造器是 private 的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是 static 的，所以也可以很方便的进行调用。

成员变量

System 类内部包含 in、out 和 err 三个成员变量，分别代表标准输入流 ( 键盘输入 )，标准输出流 ( 显示器 ) 和标准错误输出流 ( 显示器 )。

成员方法

- `native long currentTimeMillis()`：该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和 GMT 时间 ( 格林威治时间 )1970 年 1 月 1 号 0 时 0 分 0 秒所差的毫秒数。
- `void exit(int status)`：该方法的作用是退出程序。其中 status 的值为 0 代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。
- `void gc()`：该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况
- `getProperty(String key)`：该方法的作用是获得系统中属性名为 key 的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：  

<img src="image/系统方法.png" alt="系统方法" style="zoom:50%;" />

```java
public class OtherClassTest {
    @Test
    public void test1() {
        String javaVersion = System.getProperty("java.version");
        System.out.println("java 的 version:" + javaVersion);

        String javaHome = System.getProperty("java.home");
        System.out.println("java 的 home:" + javaHome);

        String osName = System.getProperty("os.name");
        System.out.println("os 的 name:" + osName);

        String osVersion = System.getProperty("os.version");
        System.out.println("os 的 version:" + osVersion);

        String userName = System.getProperty("user.name");
        System.out.println("user 的 name:" + userName);

        String userHome = System.getProperty("user.home");
        System.out.println("user 的 home:" + userHome);
        
        String userDir = System.getProperty("user.dir");
        System.out.println("user 的 dir:" + userDir);
    }
}
```



### 9.6.2 Math类

java.lang.Math 提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为 double 型。

|            方法            |                    功能                    |
| :------------------------: | :----------------------------------------: |
|            abs             |                   绝对值                   |
| acos,asin,atan,cos,sin,tan |                  三角函数                  |
|            sqrt            |                   平方根                   |
|   pow(double a,doble b)    |                a 的 b 次幂                 |
|            log             |                  自然对数                  |
|            exp             |                 e为底指数                  |
|   max(double a,double b)   |                   最大值                   |
|   min(double a,double b)   |                   最小值                   |
|          random()          |          返回 0.0 到 1.0 的随机数          |
|    long round(double a)    | double 型数据 a 转换为 long 型（四舍五入） |
|  toDegrees(double angrad)  |                弧度—> 角度                 |
|  toRadians(double angdeg)  |                角度—> 弧度                 |



### 9.6.3 BigInteger与BigDecimal

Integer 类作为 int 的包装类，能存储的最大整型值为 2^31 -1，Long 类也是有限的，最大为 2^63 -1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。

java.math 包的 BigInteger 可以表示不可变的任意精度的整数。BigInteger提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。

构造器：

- `BigInteger(String val)`：根据字符串构建 BigInteger 对象。

常用方法：

- `Public BigInteger abs()`：返回此 BigIntger 的绝对值的 BigInteger。
- `BigInteger add(BigInteger val)`：返回其值为 ($this + val$) 的 Biglnteger。
- `BigInteger subtract(BigInteger val)`：返回其值为 ($this - val$) 的 BigInteger。
- `BigInteger multiply(BigInteger val)` ：返回其值为 ($this * val$) 的 Biglnteger。
- `BigInteger divide(BigInteger val)` ：返回其值为 ($this / val$) 的 Biglntegero 整数相除只保留整数部分。
- `BigInteger remainder(BigInteger val)`：返回其值为 ($this\%val$) 的 BigInteger。
- `BigIntegerD divideAndRemainder(BigInteger val)`：返回包含 ($this/val$) 后跟(this%val) 的两个 BigInteger 的数组。
- `BigInteger pow(int exponent)`：返回其值为 ($this^{expoment}$ ) 的 BigIntege。

一般的 Float 类和 Double 类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到 java.math.BigDecimal 类。BigDecimal 类支持**<u>*不可变的、任意精度*</u>**的有符号十进制定点数。  

构造器：

- `public BigDecimal(double val)`
- `public BigDecimal(String val)`

常用方法：

- `public BigDecimal add(BigDecimal augend)`
- `public BigDecimal subtract(BigDecimal subtrahend)`
- `public BigDecimal multiply(BigDecimal multiplicand)`
- `public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)`

```java
public class OtherClassTest {
   
    @Test
    public void test2() {
        BigInteger bi = new BigInteger("1243324112234324324325235245346567657653");
        BigDecimal bd = new BigDecimal("12435.351");
        BigDecimal bd2 = new BigDecimal("11");
        System.out.println(bi);
        // System.out.println(bd.divide(bd2));
        System.out.println(bd.divide(bd2, RoundingMode.HALF_UP));
        System.out.println(bd.divide(bd2, 25, RoundingMode.HALF_UP));
    }
    
}
```



