# 深入理解ZGC回收器

[toc]

---

ZGC（The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器，它的设计目标包括：

- 停顿时间不超过10ms；
- 停顿时间不会随着堆的大小，或者活跃对象的大小而增加；
- 支持8MB~4TB级别的堆（未来支持16TB）。



## 1 ZGC诞生的背景

### 1.1 GC之痛

**STW**（Stop-The-World）问题是垃圾回收过程中所有应用线程被强制暂停等待垃圾回收完成的现象，这会导致应用程序响应延迟，影响用户体验和系统性能，特别是在处理大量数据或高并发请求的场景下，STW问题更为突出，成为优化高性能应用的关键挑战。例如，在在线游戏服务器、金融交易系统或实时数据分析平台中，STW现象可能导致玩家体验卡顿、交易延迟或数据处理中断，严重影响系统稳定性和用户满意度。这些场景对延迟极其敏感，STW问题的出现会直接损害业务运行效率。为解决这个问题，一款跨时代的垃圾回收器ZGC诞生。

### 1.2 CMS与G1瓶颈

在介绍ZGC之前，首先回顾一下CMS和G1的GC过程以及停顿时间的瓶颈。CMS新生代的Young GC、G1和ZGC都基于标记-复制算法，但算法具体实现的不同就导致了巨大的性能差异。

标记-复制算法应用在CMS新生代（ParNew是CMS默认的新生代垃圾回收器）和G1垃圾回收器中。标记-复制算法可以分为三个阶段：

- 标记阶段，即从GC Roots集合开始，标记活跃对象；
- 转移阶段，即把活跃对象复制到新的内存地址上；
- 重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，**所有指向对象旧地址的指针都要调整到对象新的地址上**。

下面以G1为例，通过G1中标记-复制算法过程（G1的Young GC和Mixed GC均采用该算法），分析G1停顿耗时的主要瓶颈。G1垃圾回收周期如下图所示：

<img src="./5-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ZGC%E5%9B%9E%E6%94%B6%E5%99%A8.assets/20241018-2.png" alt="20241018-2" style="zoom: 33%;" />



G1的混合回收过程可以分为标记阶段、清理阶段和复制阶段。

**标记阶段停顿分析**

- 初始标记阶段：初始标记阶段是指从GC Roots出发标记全部直接子节点的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短；
- 并发标记阶段：并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短；
- 再标记阶段：重新标记那些在并发标记阶段发生变化的对象。**该阶段是STW的**。

**清理阶段停顿分析**

- 清理阶段清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的。

**复制阶段停顿分析**

- 复制算法中的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。

四个STW过程中，初始标记因为只标记GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。因此，G1停顿时间的瓶颈主要是标记-复制中的**==转移阶段==**STW。

> **为什么转移阶段不能和标记阶段一样并发执行呢？**
>
> 主要是G1未能解决转移过程中准确定位对象地址的问题。
>
> G1的Young GC和CMS的Young GC，其标记-复制全过程STW，这里不再详细阐述。

## 2 ZGC特点

### 2.1目标

<img src="./5-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ZGC%E5%9B%9E%E6%94%B6%E5%99%A8.assets/20241018-3.png" alt="20241018-3" style="zoom: 25%;" />

- **低延迟保证：**ZGC旨在将垃圾回收引起的暂停时间控制在**毫秒级别**，即使在处理**TB级堆内存**的情况下，也能保持极低的停顿时间，非常适合对延迟敏感的应用。
- **并行与并发处理：**ZGC充分利用**多核处理器**的能力，实现并行的垃圾回收操作，并且在部分阶段能够与应用线程并发执行，极大减少了STW事件的发生，提高了系统的整体响应速度。
- **可扩展性：**ZGC针对现代数据中心的大内存环境进行了优化，**支持从几GB到数TB的堆大小**，适应了从小型服务器到大规模集群的广泛部署场景。
- **无碎片内存管理：**通过实现无碎片的内存分配和回收机制，**ZGC避免了内存碎片化问题**，简化了内存管理，从而提升了内存使用效率和应用性能。
- **自适应调整：**ZGC具备智能的**==自适应能力==**，能够根据系统当前的负载情况动态调整垃圾回收策略，确保在不同工作负载下都能维持良好的性能表现。
- **详尽的性能监控：**提供了丰富的垃圾回收日志和监控工具，帮助开发者深入理解ZGC的行为，进行性能调优，确保应用在各种条件下都能达到最优状态。

### 2.2 性能表现

1. **从最大吞吐量与关键吞吐量指标观察，可以看出ZGC在关键吞吐量表现很突出**

<img src="./5-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ZGC%E5%9B%9E%E6%94%B6%E5%99%A8.assets/20241018-4.png" alt="20241018-4" style="zoom:25%;" />

2. **从停顿时间指标来观察，停顿时间是 ==断崖式领先==**

<img src="./5-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ZGC%E5%9B%9E%E6%94%B6%E5%99%A8.assets/20241018-5.png" alt="20241018-5" style="zoom:25%;" />

## 3 ZGC流程简介

<img src="./5-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ZGC%E5%9B%9E%E6%94%B6%E5%99%A8.assets/20241018-1.png" alt="20241018-1" style="zoom: 25%;" />

1. **初始标记阶段：**
   ZGC初始化时会为堆分配内存，并将所有对象标记为“存活”状态。

2. **并发标记阶段：**
   这个阶段主要识别哪些对象是不再使用的。ZGC使用了基于Card Table的追踪算法（G1中的CSet与RSet概念）来发现引用关系。标记过程是并发的，意味着它可以与应用程序的执行同时进行，以减少停顿时间。在这个过程中，ZGC会维护一个引用队列，用于跟踪新创建的对象或更新的引用。

3. **再标记阶段：**
   虽然ZGC的目标是最小化暂停时间，但仍然需要短暂的暂停来安全地重定位对象。
   在这个短暂的暂停期间，ZGC会更新根集（如线程栈、JNI全局引用等）和其他需要更新的地方，确保所有引用指向正确的位置。对象被移动到新的位置，以优化内存布局和减少碎片。

4. **并发转移准备阶段：**
   这个阶段是在上一步暂停之后开始的，它是**并发执行**的，**==准备重定位对象==**。ZGC会计算每个区域中的对象需要移动的距离，以及更新引用所需的更改。

5. **初始转移阶段：**
   在此阶段，ZGC实际**移动对象并更新引用**。

6. **并发转移阶段：**
   清理阶段**==处理一些剩余的任==**，如释放不再需要的内存块，更新元数据等。这个阶段也是并发的，对应用程序的影响最小。

> 但是，在一次GC之后，并**==不会真正的执行完流程==**，它是需要两次GC才能完整的执行完一次垃圾回收，这就涉及到了后面要提到的指针着色技术，使用这样的技术极大的提升了效率。



## 4 关键技术1—堆内存布局

### 4.1 G1的内存布局

让我先回顾一下**G1的内存布局**如下：

<img src="./5-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ZGC%E5%9B%9E%E6%94%B6%E5%99%A8.assets/Slide9.PNG" alt="Slide9" style="zoom:50%;" />

G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

### 4.2 ZGC的内存布局

类似的，ZGC中没有了分代的概念（新生代、老年代），内存布局如下图所示：

<img src="./5-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ZGC%E5%9B%9E%E6%94%B6%E5%99%A8.assets/20241018-6.png" alt="20241018-6" style="zoom:33%;" />

ZGC支持**3种**页面（ZPages），分别为小页面、中页面和大页面。其中小页面指的是2MB的页面空间，中页面指32MB的页面空间，大页面指受操作系统控制的大页。

- 当对象大小小于等于256KB时，对象分配在小页面；
- 当对象大小在256KB和4M之间，对象分配在中页面；
- 当对象大于4M，对象分配在大页面；

ZGC对于不同页面回收的策略也不同。**简单地说，小页面优先回收；中页面和大页面则尽量不回收。**同时ZGC 的物理堆区域可以映射到更大的堆地址空间（可以包括虚拟内存），这对于解决内存碎片问题至关重要

> 想象一下，用户想要在堆内存中分配一个非常大的对象，但由于内存中没有连续的空间，这通常会需要多个 GC 周期来释放足够的连续空间。而且如果GC后还没有可用空间，，JVM 就是抛出`OutOfMemoryError`。但是由于物理内存映射到更大的地址空间，找到更大的连续空间对于ZGC是可行的。



## 5 关键技术2🌟—指针着色技术Colored Pointers 

在 ZGC 中，Colored Pointers 主要用于解决并发垃圾回收过程中的指针更新问题。ZGC 使用了一种称为**“==指针压缩==”**的技术，其中指针的一部分位被用来存储额外的信息，以便于垃圾回收器进行高效的并发操作。

以下是颜色指针的数据结构：

<img src="./5-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ZGC%E5%9B%9E%E6%94%B6%E5%99%A8.assets/20241017-7.png" alt="20241017-7" style="zoom: 50%;" />

在堆中指针指引结构如下：

<img src="./5-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ZGC%E5%9B%9E%E6%94%B6%E5%99%A8.assets/20241018-8.png" alt="20241018-8" style="zoom: 33%;" />

具体来说，ZGC 使用了以下几种状态来标记指针：

- **未标记（Unmarked）：**指针没有任何特殊标记，表示该对象还没有被垃圾回收器处理。
- **标记（Marked）：**指针被标记为已处理，表示该对象已经被垃圾回收器发现并处理过。
- **重定位（Relocated）：**指针被标记为已重定位，表示该对象已经被移动到新的内存位置，并且指针指向了新的位置。

这些状态通常通过指针的最低几位来实现。例如，ZGC 可能会使用指针的最低两位来存储这些状态信息。

### 5.1 具体实现

- 未标记（Unmarked）：指针的最低两位为 00。表示该对象还没有被垃圾回收器处理。
- 标记（Marked）：指针的最低两位为 01。表示该对象已经被垃圾回收器发现并处理过。
- 重定位（Relocated）：指针的最低两位为 10。表示该对象已经被移动到新的内存位置，并且指针指向了新的位置。

**并发垃圾回收过程**

1. 标记阶段：
   - 垃圾回收器遍历对象图，将发现的对象标记为 Marked。
   - 如果对象需要被移动，垃圾回收器会将其标记为 Relocated，并将指针更新为新位置。
2. 更新指针：
   - 在并发阶段，应用程序线程继续运行，可能会修改对象图。
   - 垃圾回收器需要确保在更新指针时不会丢失对已移动对象的引用。
3. 清除阶段：  
   - 垃圾回收器清理未被标记的对象，释放内存。
   - 通过这种方式，ZGC 能够在并发垃圾回收过程中高效地管理和追踪对象引用，减少停顿时间并提高整体性能。

### 5.2 GC中的应用

首先是初始阶段，使用蓝色来表示Remapped

<img src="./5-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ZGC%E5%9B%9E%E6%94%B6%E5%99%A8.assets/20241018-9.png" alt="20241018-9" style="zoom: 33%;" />

接下来我们以M0区域表示第一次GC的指针染色，根据我们熟知的GC的根可达算法，将指针标记为绿色，表示此次我们GC存活的对象指针是用绿色表示

<img src="./5-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ZGC%E5%9B%9E%E6%94%B6%E5%99%A8.assets/20241018-10.png" alt="20241018-10" style="zoom:33%;" />

接下来就开始执行转移，可以看到使用了复制算法，将对象移动到了新的页，然后开始了初始阶段我们的**==GCROOT也会指向新的页==**，这时候还没有进行指针标记，那么会通过一个转发表的数据结构，在新的页中，来指向我们旧页的对象，这样的话就会成功引用到我们即将保留的对象。

<img src="./5-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ZGC%E5%9B%9E%E6%94%B6%E5%99%A8.assets/20241018-11.png" alt="20241018-11" style="zoom: 33%;" />

接下来就清空旧页的对象将被回收的对象

<img src="./5-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ZGC%E5%9B%9E%E6%94%B6%E5%99%A8.assets/20241018-12.png" alt="20241018-12" style="zoom:33%;" />

此时已经到达**==第二轮GC标记==**，那么此次M0为红色，那么就会判断上次GC的绿色指针进行并发标记，此次标记为红色表示次轮GC的存活对象指针标识，最后清空旧页的指针以及转发表等数据

<img src="./5-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ZGC%E5%9B%9E%E6%94%B6%E5%99%A8.assets/20241018-13.png" alt="20241018-13" style="zoom: 33%;" />

由此可以看出，ZGC是经历了两轮GC才会真正的将垃圾清除，通过颜色指针的M0与M1交替标记，来通过根可达算法标识存活对象，在整个过程可以看到，STW的时间点在初始标记，再标记，以及初始转移，这些动作仅仅与GCROOT的头节点的对象有关，所以标记以及转移动作特别快，**==然后大批量的标记和转移都是并发的==**，所以整体STW时间停顿特别少，而且回收的过程又是复制算法，所以非常高效。具体回收过程如下图所示：

<img src="./5-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ZGC%E5%9B%9E%E6%94%B6%E5%99%A8.assets/20241018-14.png" alt="20241018-14" style="zoom:33%;" />

## 6 关键技术3—读屏障

之前的GC都是采用写屏障（Write Barrier），而ZGC采用的是读屏障。读屏障（Load Barriers）类似于 Spring AOP 的前置通知。

在ZGC中，当读取处于重分配集的对象时，会被读屏障拦截，通过转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为叫做指针的「**自愈能力**」。这样就算GC把对象移动了，读屏障也会发现并修正指针，于是应用代码就永远都会持有更新后的有效指针，而且不需要STW，类似JDK里的**==CAS==**自旋，读取的值发现已经失效了，需要重新读取。

> **好处是：第一次访问旧对象访问会变慢，但也只会有一次变慢，当「自愈」完成后，后续访问就不会变慢了。**
>
> 正是因为Load Barriers的存在，所以会导致配置ZGC的应用的吞吐量会变低。不过这点开销是值得的。

读屏障示例：

```Java
Object o = obj.FieldA   // 从堆中读取引用，需要加入屏障
<Load barrier>
Object p = o  // 无需加入屏障，因为不是从堆中读取引用
o.dosomething() // 无需加入屏障，因为不是从堆中读取引用
int i =  obj.FieldB  //无需加入屏障，因为不是对象引用
```

## 7 总结

相比G1、Shenandoah等先进的垃圾收集器，ZGC在实现细节上做了一些不同的权衡选择。

譬如G1需要通过写屏障来维护记忆集，才能处理跨代指针，得以实现Region的增量回收。记忆集要占用大量的内存空间，写屏障也对正常程序运行造成额外负担，这些都是权衡选择的代价。

**ZGC就完全没有使用记忆集，它甚至连分代都没有，连像CMS中那样只记录新生代和老年代间引用的卡表也不需要，因而完全没有用到写屏障，所以给用户线程带来的运行负担也要小得多。**

> **可是，有优就有劣，ZGC的这种选择也限制了它能承受的对象分配速率不会太高。**
>
> 因为ZGC四个阶段都支持并发，如果分配速率高，将创造大量的新对象，这就产生了大量的**浮动垃圾**。如果这种高速分配持续维持的话，回收到的内存空间持续小于期间并发产生的浮动垃圾所占的空间，堆中剩余可腾挪的空间就越来越小了。
>
> 目前唯一的办法就是尽可能地增加堆容量大小，获得更多喘息的时间。**但是若要从根本上提升ZGC能够应对的对象分配速率，还是需要引入分代收集，让新生对象都在一个专门的区域中创建。所以分代算法有利有弊。**

