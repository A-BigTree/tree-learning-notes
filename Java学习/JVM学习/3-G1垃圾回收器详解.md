# 深入理解G1回收器

[toc]

---

G1(Garbage-First)，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

## 1 G1概述

### 1.1 堆内存模型

堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。

<img src="./3-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3.assets/HeapStructure.png" alt="HeapStructure" style="zoom:50%;" />

G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。

<img src="./3-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3.assets/Slide9.PNG" alt="Slide9" style="zoom:50%;" />

通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

### 1.2 G1回收机制

G1 收集器的运作大致分为以下几个步骤：

- **初始标记**
- **并发标记**
- **最终标记**
- **筛选回收**

![g1-garbage-collector](./3-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3.assets/g1-garbage-collector.png)

在垃圾回收时，G1 的运行方式与 CMS 收集器类似。G1 并发执行全局标记来**确定整个堆中对象的活跃度**。标记阶段完成后，G1 知道哪些区域大部分是空的。它首先在这些区域进行收集，这通常会产生大量可用空间，这是也为什么G1回收机制被称为垃圾回收优先。G1将收集和压缩的操作集中在可能充满可回收对象（即垃圾）的区域上。同时G1 使用**停顿预测模型**来满足用户定义的暂停时间，并根据指定的暂停时间选择要收集的区域（ Region）数量。

G1 将对象从堆的一个或多个区域复制到堆上的单个区域，并在此过程中压缩和释放内存。这个复制清除操作会并行执行来减少暂停时间并提高吞吐量。所以每次垃圾收集时，G1 都会在用户定义的暂停时间内持续工作来减少碎片空间

>  与CMS和ParallelOld的区别。
>
>  - CMS（并发**==标记清除==**）垃圾收集器不进行整理或复制。
>  - ParallelOld 垃圾收集是对**整个堆**进行整理，会造成相当长的SWT。

### 1.3 RSet&CSet

**每个 Region 都有**一个 Remembered Set（RSet），用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

还有一种数据结构也是辅助GC的：Collection Set（CSet），它记录了GC要收集的Region集合，集合里的Region可以是任意年代的。

RSet与Card Table有些类似，是一种典型的空间换时间工具。在GC的时候，对于old->young和old->old的跨代对象引用，只要扫描对应的CSet中的RSet即可。 逻辑上说每个Region都有一个RSet，RSet记录了其他Region中的对象引用本Region中对象的关系，**==属于points-into结构（谁引用了我的对象）==**。而Card Table则是一种points-out（我引用了谁的对象）的结构，每个Card 覆盖一定范围的Heap（一般为512Bytes）。G1的RSet是在Card Table的基础上实现的：每个Region会在对应的RSet中记录下别的Region有指向自己的指针，并标记这些指针分别在哪些Card的范围内。 这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。

<img src="./3-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3.assets/5aea17be.jpg" alt="5aea17be" style="zoom: 80%;" />

> **RSet是怎么配合CSet进行快速垃圾分析的？**
>
> GC时GC Root的对象只可能在两个位置：
>
> - CSet里的Region
> - 非CSet里的Region
>
> CSet是需要收集的region集合而非CSet里的region不需要收集，如果GC Root对象在CSet的Region里，依次遍历可达对象即可；如果GC Root在非CSet里，就需要依次遍历从非CSet到CSet里对象的引用即扫描所有非CSet region，非常耗时。
>
> 如果有了RSet,通过扫描CSet里所有Region的RSet就能知道不参与收集的其他Region对CSet中对象的引用，避免了全局扫描这些不参与收集的Region（有点绕😵‍💫）



> **RSet和CSet的引入不会影响JVM堆的利用率吗？**
>
> 根据官网介绍，使用G1的JVM进程会更大一些，但RSets 的整体占用空间影响小于 5%，同时CSet中的所有活动数据在 GC 期间都会被清除（复制/移动），对 JVM 空间的影响不到 1%。

### 1.4 SATB

全称是Snapshot-At-The-Beginning，由字面理解，是GC开始时活着的对象的一个快照。它是通过Root Tracing得到的，作用是**维持并发GC的正确性**。 那么它是怎么维持并发GC的正确性的呢？根据三色标记算法，我们知道对象存在三种状态：

- 白：对象没有被标记到，标记阶段结束后，会被当做垃圾回收掉；
- 灰：对象被标记了，但是它的field还没有被标记或标记完；
- 黑：对象被标记了，且它的所有field也被标记完了；

由于并发阶段的存在，Mutator线程（应用/用户线程）和Garbage Collector线程同时对对象进行修改，就会出现白对象漏标的情况，这种情况发生的前提是：

1. 有至少一个黑色对象在自己被标记之后指向了这个白色对象
2. 所有的灰色对象在自己引用扫描完成之前删除了对白色对象的引用

对于第一个条件，在并发标记阶段，如果该白对象是new出来的，并没有被灰对象持有，那么它会不会被漏标呢？Region中有两个top-at-mark-start（TAMS）指针，分别为prevTAMS和nextTAMS。在TAMS以上的对象是新分配的，这是一种隐式的标记。**==对于在GC时已经存在的白对象，如果它是活着的，它必然会被另一个对象引用，即条件二中的灰对象==**。如果灰对象到白对象的直接引用或者间接引用被替换了，或者删除了，白对象就会被漏标，从而导致被回收掉，这是非常严重的错误，所以SATB破坏了第二个条件。也就是说，一个对象的引用被替换时，可以通过write barrier 将旧引用记录下来。

![16588065077599](./3-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3.assets/16588065077599.jpg)

**这种方式有个缺点，就是会产生浮动垃圾。** 因为当用户线程取消引用的时候，有可能是真的取消引用，对应的对象是真的要回收掉的。这时候我们通过这种方式，就会把本该回收的对象又复活了，从而导致出现浮动垃圾。但相对于本该存活的对象被回收，这个代价还是可以接受的，毕竟在下次 GC 的时候就可以回收了。

> **CMS也有并发标记过程，它是怎么解决这个问题的呢？**
>
> **CMS 回收器采用的是增量更新方案，即破坏第一个条件：「有至少一个黑色对象在自己被标记之后指向了这个白色对象」。**
>
> 既然有黑色对象在自己标记后，又重新指向了白色对象。那么我就把这个黑色对象的引用记录下来，在后续「重新标记」阶段再以这个黑色对象为根，对其引用进行重新扫描。通过这种方式，被黑色对象引用的白色对象就会变成灰色，从而变为存活状态。
>
> 这种方式有个缺点，就是会重新扫描新增的这部分黑色对象，会浪费多一些时间。但是这段时间相对于并发标记整个链路的扫描，还是小巫见大巫，毕竟真正发生引用变化的黑色对象是比较少的。

### 1.5 可预测停顿

Pause Prediction Model 即停顿预测模型。它在G1中的作用是：

> G1 uses a pause prediction model to meet a user-defined pause time target and selects the number of regions to collect based on the specified pause time target.

G1 GC是一个响应时间优先的GC算法，它与CMS最大的不同是，用户可以设定整个GC过程的期望停顿时间，参数`-XX:MaxGCPauseMillis`指定一个G1收集过程目标停顿时间，默认值`200ms`，不过它不是硬性条件，只是期望值。那么G1怎么满足用户的期望呢？就需要这个停顿预测模型了。G1根据这个模型统计计算出来的历史数据来预测本次收集需要选择的Region数量，从而尽量满足用户设定的目标停顿时间。 停顿预测模型是以衰减标准偏差为理论基础实现的。

<img src="./3-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3.assets/f7a41711640779.jpg" alt="f7a41711640779" style="zoom: 67%;" />

（有点复杂，感兴趣的小伙伴可以自己深入探索一下😵‍💫）

## 2 G1垃圾回收过程

### 2.1 与CMS回收过程做比较

从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“==标记-清除==”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

![cms-garbage-collector](./3-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3.assets/cms-garbage-collector.png)

### 2.2 G1垃圾回收过程详解

G1 收集器的运作大致分为以下几个步骤：

- **初始标记**：这是一次SWT事件。对于G1正常的年轻代 GC 上。标记可能引用老生代对象的新生代区域（引用根区域）；
- **并发标记**： 在整个堆中查找活动对象，与应用线程并行，此阶段可能会被新生代GC中断；
- **最终标记**：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
- **筛选回收**：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

![g1-garbage-collector](./3-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3.assets/g1-garbage-collector.png)

G1收集可以分为两大部分：

- 全局并发标记（global concurrent marking）；
- 拷贝存活对象（evacuation），或者叫迁移；

### 2.3 全局并发标记Global concurrent marking

> **标记老年代region，提供统计结果供Mixed GC使用，选取收益高的老年代region回收，帮助回收老年代对象。**

Global concurrent marking基于SATB形式的并发标记，分为以下几个阶段：

1. The Initial Mark Phase（STW）：扫描GC roots直接可达对象，并将他们的字段压入扫描栈（marking stack）等待后续扫描。初始标记阶段借用young gc的暂停，没有额外的单独暂停阶段，所以在The Initial Mark Phase发生在young gc之后。

<img src="./3-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3.assets/Slide13.PNG" alt="Slide13" style="zoom:50%;" />

2. The Concurrent Marking Phase：从扫描栈（marking stack）中递归查找所有引用可达对象。和用户线程并行执行。

<img src="./3-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3.assets/Slide14.PNG" alt="Slide14" style="zoom:50%;" />

3. The Remark Phase（STW）:完成存活对象的标记，标记那些在并发标记阶段发生变化的对象，将被回收。

<img src="./3-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3.assets/Slide15.PNG" alt="Slide15" style="zoom:50%;" />

4. The Cleanup Phase （STW and Concurrent）:old region存活对象情况统计(确定未使用region和Mixed GC收集候选region)(Stop the world)；将空闲region重置到空闲列表中（concurrent）；

<img src="./3-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3.assets/Slide16.PNG" alt="Slide16" style="zoom:50%;" />

最终所选区域已被收集并压缩为图中所示的深蓝色区域和深绿色区域：

<img src="./3-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3.assets/Slide17.PNG" alt="Slide17" style="zoom:50%;" />



### 2.4 拷贝存活对象Evacuation

Evacuation阶段是**全暂停**的。它负责把一部分region里的活对象拷贝到空region里去，然后回收原本的region的空间。Evacuation阶段可以自由选择任意多个region来独立收集构成CSet），考RSet实现。这是regional garbage collector的特征。

G1有两种GC模式：Young GC和Mixed GC，Young GC和Mixed GC都是STW。

- Young GC：选定所有年轻代region添加到CSet中。通过控制年轻代region的个数来，即年轻代内存的大小，来控制young GC的时间开销。
- Mixed GC：选定所有年轻代region，外加根据global concurrent marking统计结果得出的收益高的若干老年代region添加到CSet中。在用户指定开销返回内尽可能选择收益高的老年代region。

在选定CSet后，Evacuation其实就跟ParallelScavenge的Young GC的算法类似，采用并行copying（或者叫scavenging）算法把CSet里每个region里的活对象**拷贝**到新的region里，整个过程完全暂停。从这个意义上说，G1的Evacuation跟传统的标记整理算法的compaction完全不同：前者会自己从根集合遍历对象图来判定对象的生死，不需要依赖全局并发标记的结果（有就用没有拉倒)；而后者则依赖于之前的mark阶段对对象生死的判定。

CSet的选定完全靠统计模型找处收益最高、开销不超过用户指定的上限的若干region。由于每个region都有RSet覆盖，要单独evacuate任意一个或多个region都没问题。

可以看到**young gen region总是在CSet内**。因此分代式G1不维护从young gen region出发的引用涉及的RSet更新。**Mixed GC**不是**Full GC**，因为Mixed GC只收集部分老年代region，如果在Mixed GC期间出现老年代被占用完的情况，JVM会采用Serial Old(Full GC)收集器来收集整个Heap。

老年代region回收完全依赖于Mixed GC。G1的正常工作流程就是在Young GC和Mixed GC之间视情况切换，背后定期做global concurrent marking(全局并发标记)，global concurrent marking(全局并发标记)主要是为Mixed GC提供标记服务，而不是一次GC过程中的必须环节。G1的所有concurrent动作都在global concurrent marking里。Young GC和Mixed GC都是完全暂停的。

> **Young GC 和Mixed GC都是STW，为什么G1还可以被称为低延迟的GC实现呢？**
>
> 可以看到在这么多步骤里，G1只有两件事是并发执行的：(1) 全局并发标记；(2) logging write barrier的部分处理。而“拷贝对象”（evacuation）这个很耗时的动作却不是并发而是完全暂停的。那G1为何还可以叫做低延迟的GC实现呢？
>
> 重点就在于G1虽然会mark整个堆，但并不evacuate所有有活对象的region；**通过只选择收益高的少量region来evacuate，这种暂停的开销就可以（在一定范围内）可控。每次evacuate的暂停时间应该跟一般GC的young GC类似**。所以G1把自己标榜为“软实时”（soft real-time）的GC。

