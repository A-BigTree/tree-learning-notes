# 分布式事务

[toc]

---

## 1 本地事务

在计算机系统中，更多的是通过关系型数据库来控制事务，这是利用数据库本身的事务特性来实现的，因此叫数据库事务，由于应用主要靠关系数据库来控制事务，而数据库通常和应用在同一个服务器，所以基于关系型数据库的事务又被称为本地事务。

数据库事务的四大特性：ACID

### 1.1 A（Atomic）

原子性，构成事务的所有操作，要么都执行完成，要么全部不执行，不可能出现部分成功部分失败的情况。

### 1.2 C（Consistency）

一致性，在事务执行前后，数据库的一致性约束没有被破坏。比如：张三向李四转 100 元，转账前和转账后的数据是正确状态这叫一致性，如果出现张三转出 100 元，李四账户没有增加 100 元这就出现了数 据错误，就没有达到一致性。

### 1.3 I（Isolation）

隔离性，数据库中的事务一般都是并发的，隔离性是指并发的两个事务的执行互不干扰，一个事务不能看到其他事务的运行过程的中间状态。通过配置事务隔离级别可以比避免脏读、重复读问题。

### 1.4 D（Durability）

持久性，事务完成之后，该事务对数据的更改会持久到数据库，且不会被回滚。

数据库事务在实现时会将一次事务的所有操作全部纳入到一个不可分割的执行单元，该执行单元的所有操作要么都成功，要么都失败，只要其中任一操作执行失败，都将导致整个事务的回滚。



## 2 分布式事务

随着互联网的快速发展，软件系统由原来的单体应用转变为分布式应用，分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为**分布式事务**，例如用户注册送积分事务、创建订单减库存事务，银行转账事务等都是分布式事务。

 我们知道本地事务依赖数据库本身提供的事务特性来实现，因此以下逻辑可以控制本地事务：

```sql
begin transaction；
    //1.本地数据库操作：张三减少金额
    //2.本地数据库操作：李四增加金额
commit transation;
```

 但是在分布式环境下，会变成下边这样：

```sql
begin transaction；
    //1.本地数据库操作：张三减少金额
    //2.远程调用：让李四增加金额
commit transation;
```

可以设想，当远程调用让李四增加金额成功了，由于网络问题远程调用并没有返回，此时本地事务提交失败就回滚了张三减少金额的操作，此时张三和李四的数据就不一致了。

 因此在分布式架构的基础上，传统数据库事务就无法使用了，张三和李四的账户不在一个数据库中甚至不在一个应用系统里，实现转账事务需要通过远程调用，由于网络问题就会导致分布式事务问题。



## 3 分布式事务产生场景

### 3.1 跨JVM进程产生分布式事务

典型的场景就是微服务架构：微服务之间通过远程调用完成事务操作。比如：订单微服务和库存微服务，下单的同时订单微服务请求库存微服务减少库存。

### 3.2 跨数据库实例产生分布式事务

单体系统访问多个数据库实例当单体系统需要访问多个数据库（实例）时就会产生分布式事务。比如：用户信息和订单信息分别在两个MySQL实例存储，用户管理系统删除用户信息，需要分别删除用户信息及用户的订单信息，由于数据分布在不同的数据实例，需要通过不同的数据库链接去操作数据，此时产生分布式事务。

### 3.3 多服务访问同一个数据库实例

订单微服务和库存微服务即使访问同一个数据库也会产生分布式事务，原因就是跨JVM进程，两个微服务持有了不同的数据库链接进行数据库操作，此时产生分布式事务。

针对不同的分布式场景业界常见的分布式解决方案有 2PC、3PC、TCC、可靠消息最终一致性、最大努力通知这几种。

## 4 分布式事务解决方案-2PC

2PC（2-phase commit） 即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit phase）；

举例：张三和李四好久不见，老友约起聚餐，饭店老板要求先买单，才能出票。这时张三和李四分别抱怨近况不如意，囊中羞涩，都不愿意请客，这时只能AA。只有张三和李四都付款，老板才能出票安排就餐。但由于张三和李四都是铁公鸡，形成了尴尬的一幕：

准备阶段：老板要求张三付款，张三付款。老板要求李四付款，李四付款。

提交阶段：老板出票，两人拿票纷纷落座就餐。

例子中形成了一个事务，若张三或李四其中一人拒绝付款，或钱不够，店老板都不会给出票，并且会把已收款退回。

整个事务过程由事务管理器和参与者组成，店老板就是事务管理器，张三、李四就是事务参与者，事务管理器负责决策整个分布式事务的提交和回滚，事务参与者负责自己本地事务的提交和回滚。

在计算机中部分关系数据库如 Oracle、MySQL 支持两阶段提交协议如下：

1. 准备阶段（Prepare phase）：事务管理器给每个参与者发送 Prepare 消息，每个数据库参与者在本地执行事务，并写本地的 Undo/Redo 日志，此时事务没有提交。（Undo 日志是记录修改前的数据，用于数据库回滚，Redo 日志是记录修改后的数据，用于提交事务后写入数据文件）
2. 提交阶段（commit phase）：如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚（Rollback）消息；否则，发送提交（Commit）消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。注意：**必须在最后阶段释放锁资源**。

下图展示了2PC的两个阶段，分成功和失败两个情况说明：

<img src="./2-分布式事务.assets/截屏2023-08-11 17.01.19.png" alt="截屏2023-08-11 17.01.19" style="zoom: 80%;" />

### 4.1 XA方案

2PC的传统方案是在数据库层面实现的，如 Oracle、MySQL 都支持 2PC 协议，为了统一标准减少行业内不必要的对接成本，需要制定标准化的处理模型及接口标准，国际开放标准组织 Open Group 定义了分布式事务处理模型**DTP**（Distributed Transaction Processing Reference Model）。

为了让大家更明确 XA 方案的内容，下面以新用户注册送积分为例来说明：

<img src="./2-分布式事务.assets/截屏2023-08-11 17.03.34.png" alt="截屏2023-08-11 17.03.34" style="zoom:80%;" />

执行流程如下：

1. 应用程序（AP）持有用户库和积分库两个数据源；
2. 应用程序（AP）通过 TM 通知用户库 RM 新增用户，同时通知积分库RM为该用户新增积分，RM 此时并未提交事务，此时用户和积分资源锁定；
3. TM 收到执行回复，只要有一方失败则分别向其他 RM 发起回滚事务，回滚完毕，资源锁释放；
4. TM 收到执行回复，全部成功，此时向所有 RM 发起提交事务，提交完毕，资源锁释放；

DTP 模型定义如下角色：

- **AP**（Application Program）：即应用程序，可以理解为使用 DTP 分布式事务的程序。
- **RM**（Resource Manager）：即资源管理器，可以理解为事务的参与者，一般情况下是指一个数据库实例，通过资源管理器对该数据库进行控制，资源管理器控制着分支事务。
- **TM**（Transaction Manager）：事务管理器，负责协调和管理事务，事务管理器控制着全局事务，管理事务生命周期，并协调各个 RM。**全局事务**是指分布式事务处理环境中，需要操作多个数据库共同完成一个工作，这个工作即是一个全局事务。
- DTP 模型定义TM和RM之间通讯的接口规范叫 **XA**，简单理解为数据库提供的 2PC 接口协议，**基于数据库的 XA 协议来实现 2PC 又称为 XA 方案**

以上三个角色之间的交互方式如下：

```text
1. TM 向 AP 提供 应用程序编程接口，AP 通过 TM 提交及回滚事务。
2. TM 交易中间件通过 XA 接口来通知 RM 数据库事务的开始、结束以及提交、回滚等。
```

#### 时序图

<img src="./2-分布式事务.assets/截屏2023-08-15 16.17.04.png" alt="截屏2023-08-15 16.17.04" style="zoom:80%;" />

#### 总结

整个 2PC 的事务流程涉及到三个角色 AP、RM、TM。AP 指的是使用 2PC 分布式事务的应用程序；RM 指的是资源管理器，它控制着分支事务；TM 指的是事务管理器，它控制着整个全局事务。

（1）在**准备阶段** RM 执行实际的业务操作，但不提交事务，资源锁定

（2）在**提交阶段** TM 会接受 RM 在准备阶段的执行回复，只要有任一个RM执行失败，TM 会通知所有 RM 执行回滚操作，否则，TM 将会通知所有 RM 提交该事务。提交阶段结束资源锁释放。

#### XA方案的问题

1. 需要本地数据库支持XA协议。
2. 资源锁需要等到两个阶段结束才释放，性能较差。



### 4.2 SAGA方案

Saga是这一篇数据库论文saga提到的一个方案。其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。

#### 时序图

<img src="./2-分布式事务.assets/截屏2023-08-15 16.36.31.png" alt="截屏2023-08-15 16.36.31" style="zoom:80%;" />

SAGA事务的特点：

- 并发度高，不用像XA事务那样长期锁定资源
- 需要定义正常操作以及补偿操作，开发量比XA大
- 一致性较弱，对于转账，可能发生A用户已扣款，最后转账又失败的情况

论文里面的SAGA内容较多，包括两种恢复策略，包括分支事务并发执行，我们这里的讨论，仅包括最简单的SAGA，SAGA适用的场景较多，长事务适用，对中间结果不敏感的业务场景适用。

### 4.2 Seata方案

Seata 是由阿里中间件团队发起的开源项目 Fescar，后更名为 Seata，它是一个是开源的分布式事务框架。

传统 2PC 的问题在 Seata 中得到了解决，它通过对本地关系数据库的分支事务的协调来驱动完成全局事务，是工作在应用层的中间件。主要优点是性能较好，且不长时间占用连接资源，它以高效并且对业务 0 侵入的方式解决微服务场景下面临的分布式事务问题，它目前提供 AT 模式（即 2PC）及 TCC 模式的分布式事务解决方案。

**Seata 的设计思想如下：**

Seata 的设计目标其一是对业务无侵入，因此从业务无侵入的 2PC 方案着手，在**传统 2PC**的基础上演进，并解决 2PC 方案面临的问题。

Seata 把一个分布式事务理解成一个包含了若干**分支事务**的**全局事务**。全局事务的职责是协调其下管辖的分支事务达成一致，要么一起成功提交，要么一起失败回滚。此外，通常分支事务本身就是一个关系数据库的本地事务，下图是全局事务与分支事务的关系图：

<img src="./2-分布式事务.assets/截屏2023-08-15 16.24.24.png" alt="截屏2023-08-15 16.24.24" style="zoom:90%;" />

与传统 2PC 的模型类似，Seata 定义了 3 个组件来协议分布式事务的处理过程：

<img src="./2-分布式事务.assets/截屏2023-08-15 16.26.11.png" alt="截屏2023-08-15 16.26.11" style="zoom:80%;" />

- Transaction Coordinator（TC）：事务协调器，它是独立的中间件，需要独立部署运行，它维护全局事务的运行状态，接收 TM 指令发起全局事务的提交与回滚，**负责与 RM 通信协调各各分支事务的提交或回滚**；
- Transaction Manager（TM）： 事务管理器，TM 需要嵌入应用程序中工作，它**负责开启一个全局事务，并最终向 ==TC== 发起全局提交或全局回滚的==指令==**；
- Resource Manager（RM）：**控制分支事务**，负责分支注册、状态汇报，并接收事务协调器 TC 的指令，驱动分支（本地）事务的提交和回滚；

拿新用户注册送积分举例Seata的分布式事务过程：

<img src="./2-分布式事务.assets/截屏2023-08-15 16.29.32.png" alt="截屏2023-08-15 16.29.32" style="zoom:80%;" />

具体的执行流程如下：

1. **用户服务**的 TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID；
2. **用户服务**的 RM 向 TC 注册分支事务，该分支事务在用户服务执行新增用户逻辑，并将其纳入 XID 对应全局事务的管辖；
3. **用户服务**执行分支事务，向用户表插入一条记录；
4. 逻辑执行到远程调用**积分服务**时（XID 在微服务调用链路的上下文中传播）。**积分服务**的 RM 向 TC 注册分支事务，该分支事务执行增加积分的逻辑，并将其纳入 XID 对应全局事务的管辖；
5. **积分服务**执行分支事务，向积分记录表插入一条记录，**执行完毕**后，返回用户服务；
6. 用户服务分支事务**执行完毕**；
7. TM 向 TC 发起针对 XID 的全局提交或回滚决议；
8. TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求；

**Seata实现2PC与传统2PC的差别**

架构层次方面：传统 2PC 方案的 RM 实际上是在数据库层，RM 本质上就是数据库自身，通过 XA 协议实现，而 Seata 的 RM 是以 jar 包的形式作为中间件层部署在应用程序这一侧的；

两阶段提交方面：传统 2PC无论第二阶段的决议是 commit 还是 rollback ，事务性资源的锁都要保持到 Phase2 完成才释放。而 Seata 的做法是在 Phase1 就将本地事务提交，这样就可以省去 Phase2 持锁的时间，整体提高效率；



## 5 分布式事务解决方案-TCC

### 5.1 什么是TCC事务

TCC 是 Try、Conﬁrm、Cancel 三个词语的缩写，TCC 要求每个分支事务实现三个操作：预处理 Try、确认 Conﬁrm、撤销 Cancel。Try 操作做业务检查及资源预留，Conﬁrm 做业务确认操作，Cancel 实现一个与 Try 相反的操作即回滚操作。TM 首先发起所有的分支事务的 Try 操作，任何一个分支事务的Try操作执行失败，TM 将会发起所有分支事务的 Cancel 操作，若 Try 操作全部成功，TM 将会发起所有分支事务的 Conﬁrm 操作，其中 Conﬁrm/Cancel 操作若执行失败，TM 会进行**重试**。

<img src="./2-分布式事务.assets/截屏2023-08-15 16.47.09.png" alt="截屏2023-08-15 16.47.09" style="zoom:80%;" />

1. **Try** 阶段是做完业务检查（一致性）及资源预留（隔离），此阶段仅是一个初步操作，它和后续的 Conﬁrm 一起才能真正构成一个完整的业务逻辑；
2. **Confirm** 阶段是做确认提交，Try 阶段所有分支事务执行成功后开始执行 Conﬁrm。通常情况下，采用 TCC 则认为 Conﬁrm 阶段是不会出错的。即：只要 Try 成功，Conﬁrm 一定成功。若 Conﬁrm 阶段真的出错了，**需引入重试机制或人工处理**；
3. **Cancel** 阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采用 TCC 则认为 Cancel 阶段也是一定成功的。若 Cancel 阶段真的出错了，**需引入重试机制或人工处理**；

**TM 事务管理器**

TM事务管理器可以实现为独立的服务，也可以让**全局事务发起方**充当 TM 的角色，TM 独立出来是为了成为公用组件，是为了考虑系统结构和软件复用；

TM 在发起全局事务时生成全局事务记录，==**全局事务 ID**==贯穿整个分布式事务调用链条，用来记录事务上下文， 追踪和记录状态，由于 Conﬁrm 和 Cancel 失败需进行重试，因此需要实现为幂等，幂等性是指同一个操作无论请求多少次，其结果都相同。

### 5.2 TCC异常处理

TCC需要注意三种异常处理分别是**空回滚**、**幂等**、**悬挂**

#### 5.2.1 空回滚

在没有调用 TCC 资源 Try 方法的情况下，调用了二阶段的 Cancel 方法，Cancel 方法需要识别出这是一个空回滚，然后直接返回成功。出现原因是当一个分支事务所在服务宕机或网络异常，分支事务调用记录为失败，这个时候其实是没有执行 Try 阶段，当故障恢复后，分布式事务进行回滚则会调用二阶段的 Cancel 方法，从而形成空回滚。

解决思路是关键就是要识别出这个空回滚。思路很简单就是需要知道一阶段是否执行，如果执行了，那就是正常回滚；如果没执行，那就是空回滚。前面已经说过 TM 在发起全局事务时生成全局事务记录，全局事务 ID 贯穿整个分布式事务调用链条。再**额外增加一张分支事务记录表，其中有全局事务 ID 和分支事务 ID**，第一阶段 Try 方法里会插入一条记录，表示一阶段执行了。Cancel 接口里读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚。

#### 5.2.2 幂等

通过前面介绍已经了解到，为了保证 TCC 二阶段提交重试机制不会引发数据不一致，要求 TCC 的二阶段 Conﬁrm 和 Cancel 接口保证幂等，这样不会重复使用或者释放资源。如果幂等控制没有做好，很有可能导致数据不一致等严重问题。

解决思路在上述"分支事务记录"中增加执行状态，每次执行前都查询该状态。

#### 5.2.3 悬挂

悬挂就是对于一个分布式事务，其二阶段 Cancel 接口比 Try 接口先执行。

出现原因是在 RPC 调用分支事务 Try 时，先注册分支事务，再执行 RPC 调用，如果此时 RPC 调用的网络发生拥堵，通常 RPC 调用是有超时时间的，RPC 超时以后，TM 就会通知 RM 回滚该分布式事务，可能回滚完成后，RPC 请求才到达参与者真正执行，而一个 Try 方法预留的业务资源，只有该分布式事务才能使用，该分布式事务第一阶段预留的业务资源就再也没有人能够处理了，对于这种情况，我们就称为悬挂，即业务资源预留后没法继续处理。

解决思路是如果二阶段执行完成，那一阶段就不能再继续执行。在执行一阶段事务时判断在该全局事务下，"分支事务记录"表中是否已经有二阶段事务记录，如果有则不执行 Try。

### 5.3 小节

如果拿 TCC 事务的处理流程与 2PC 两阶段提交做比较，2PC 通常都是在跨库的 DB 层面，而 TCC 则在应用层面的处理，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让**应用自己定义数据操作的粒度，使得降低锁冲突、提高吞吐量成为可能**。

而不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现 Try、Conﬁrm、Cancel 三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。



## 6 分布式事务解决方案-可靠消息最终一致性

### 6.1 什么是可靠消息一致性

可靠消息最终一致性方案是指当事务发起方执行完成本地事务后并发出一条消息，事务参与方（消息消费者）一定能够接收消息并处理事务成功，此方案强调的是只要消息发给事务参与方最终事务要达到一致。

此方案是利用消息中间件完成，如下图：

<img src="./2-分布式事务.assets/截屏2023-08-15 17.13.14.png" alt="截屏2023-08-15 17.13.14" style="zoom:80%;" />

事务发起方（消息生产方）将消息发给消息中间件，事务参与方从消息中间件接收消息，事务发起方和消息中间件之间，事务参与方（消息消费方）和消息中间件之间都是通过网络通信，由于网络通信的不确定性会导致分布式事务问题。

因此可靠消息最终一致性方案要解决以下几个问题：

1. **本地事务与消息发送的原子性问题**
   本地事务与消息发送的原子性问题即：事务发起方在本地事务执行成功后消息必须发出去，否则就丢弃消息。即实现本地事务和消息发送的原子性，要么都成功，要么都失败。本地事务与消息发送的原子性问题是实现可靠消息最终一致性方案的关键问题。
   下面这种操作，先发送消息，在操作数据库：
   `mysql begin transaction； //1.发送MQ //2.数据库操作 commit transation;`
   这种情况下无法保证数据库操作与发送消息的一致性，因为可能发送消息成功，数据库操作失败。 那么第二种方案，先进行数据库操作，再发送消息：
   `mysql begin transaction； //1.数据库操作 //2.发送MQ commit transation;`
   这种情况下貌似没有问题，如果发送 MQ 消息失败，就会抛出异常，导致数据库事务回滚。但如果是超时异常，数据库回滚，但 MQ 其实已经正常发送了，同样会导致不一致。
2. **事务参与方接收消息的可靠性**
   事务参与方必须能够从消息队列接收到消息，如果接收消息失败可以重复接收消息。
3. **消息重复消费的问题**
   由于网络2的存在，若某一个消费节点超时但是消费成功，此时消息中间件会重复投递此消息，就导致了消息的重复消费。
   要解决消息重复消费的问题就要实现事务参与方的方法幂等性。

### 6.2 本地消息表方案

本地消息表这个方案最初是 eBay 提出的，此方案的核心是通过本地事务保证数据业务操作和消息的一致性，然后通过定时任务将消息发送至消息中间件，待确认消息发送给消费方成功再将消息删除。

下面以注册送积分为例来说明：下例共有两个微服务交互，用户服务和积分服务，用户服务负责添加用户，积分服务负责增加积分。

<img src="./2-分布式事务.assets/截屏2023-08-15 17.18.45.png" alt="截屏2023-08-15 17.18.45" style="zoom:80%;" />

交互流程如下：

1. **用户注册**

用户服务在本地事务新增用户和增加 "积分消息日志"。（用户表和消息表通过本地事务保证一致）
`mysql begin transaction //1.新增用户 //2.存储积分消息日志 commit transation`
这种情况下，本地数据库操作与存储积分消息日志处于同一个事务中，本地数据库操作与记录消息日志操作具备原子性。

2. **定时任务扫描日志**

如何保证将消息发送给消息队列呢？经过第一步消息已经写到消息日志表中，可以启动独立的线程，定时对消息日志表中的消息进行扫描并发送至消息中间件，在消息中间件反馈发送成功后删除该消息日志，否则等待定时任务下一周期重试。

3. **消费消息**

如何保证消费者一定能消费到消息呢？这里可以使用 MQ 的 ack（即消息确认）机制，消费者监听 MQ，如果消费者接收到消息并且业务处理完成后向 MQ 发送 ack（即消息确认），此时说明消费者正常消费消息完成，MQ 将不再向消费者推送消息，否则消费者会不断重试向消费者来发送消息。积分服务接收到"增加积分"消息，开始增加积分，积分增加成功后向消息中间件回应 ack，否则消息中间件将重复投递此消息。

由于消息会重复投递，积分服务的"增加积分"功能需要实现幂等性。



### 6.3 事务消息

在上述的本地消息表方案中，生产者需要额外创建消息表，还需要对本地消息表进行轮询，业务负担较重。阿里开源的RocketMQ 4.3之后的版本正式支持事务消息，该事务消息本质上是把本地消息表放到RocketMQ上，解决生产端的消息发送与本地事务执行的原子性问题。

事务消息发送及提交：

- 发送消息（half消息）
- 服务端存储消息，并响应消息的写入结果
- 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）
- 根据本地事务状态执行Commit或者Rollback（Commit操作发布消息，消息对消费者可见）

正常发送的流程图如下：

<img src="./2-分布式事务.assets/截屏2023-08-16 14.40.56.png" alt="截屏2023-08-16 14.40.56" style="zoom:80%;" />

==**补偿流程：**==

对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查” Producer收到回查消息，返回消息对应的本地事务的状态，为Commit或者Rollback 事务消息方案与本地消息表机制非常类似，区别主要在于原先相关的本地表操作替换成了一个反查接口。

事务消息特点如下：

- 长事务仅需要分拆成多个任务，并提供一个反查接口，使用简单；
- 消费者的逻辑如果无法通过重试成功，那么还需要更多的机制，来回滚操作；

适用于可异步执行的业务，且后续操作无需回滚的业务



### 6.4 小结

可靠消息最终一致性就是保证消息从生产方经过消息中间件传递到消费方的一致性：

1. 本地事务与消息发送的原子性问题。
2. 事务参与方接收消息的可靠性。

可靠消息最终一致性事务适合执行周期长且实时性要求不高的场景。引入消息机制后，同步的事务操作变为基于消息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响，并实现了两个服务的解耦。



## 7 分布式事务解决方案-最大努力通知

### 7.1 什么是最大努力通知

最大努力通知也是一种解决分布式事务的方案，下边是一个是充值的例子：

<img src="./2-分布式事务.assets/截屏2023-08-16 15.26.49.png" alt="截屏2023-08-16 15.26.49" style="zoom:80%;" />

交互流程：

1. 账户系统调用充值系统接口；
2. 充值系统完成支付处理向账户发起充值结果通知，若通知失败，则充值系统按策略进行重复通知；
3. 账户系统接收到充值结果通知修改充值状态；
4. 账户系统未接收到通知会主动调用充值系统的接口查询充值结果；

通过上边的例子我们总结最大努力通知方案的目标：**发起通知方通过一定的机制最大努力将业务处理结果通知到接收方**。

具体包括：

1. 有一定的消息重复通知机制。因为接收通知方可能没有接收到通知，此时要有一定的机制对消息重复通知；
2. 消息校对机制。如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求；

最大努力通知与可靠消息一致性有什么不同？

1. **解决方案思想不同**
   - 可靠消息一致性，发起通知方需要保证将消息发出去，并且将消息发到接收通知方，消息的可靠性关键由发起通知方来保证；
   - 最大努力通知，发起通知方尽最大的努力将业务处理结果通知为接收通知方，但是可能消息接收不到，此时需要接 收通知方主动调用发起通知方的接口查询业务处理结果，通知的可靠性关键在接收通知方；
2. **两者的业务应用场景不同**
   - 可靠消息一致性关注的是交易过程的事务一致，以异步的方式完成交易；
   - 最大努力通知关注的是交易后的通知事务，即将交易结果可靠的通知出去；
3. **技术解决方向不同**
   - 可靠消息一致性要解决消息从发出到接收的一致性，即消息发出并且被接收到；
   - 最大努力通知无法保证消息从发出到接收的一致性，只提供消息接收的可靠性机制。可靠机制是，最大努力的将消息通知给接收方，当消息无法被接收方接收时，由接收方主动查询消息（业务处理结果）；





